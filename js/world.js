/**
 * 3d world for graphics learning studio
 * handles terrain, stations, and interactive elements
 */

//=============================================================================
// GLOBAL VARIABLES AND CONSTANTS
//=============================================================================

// world objects
let terrain, skybox;
let learningStations = {};
let currentStation = null;

// Initialize station controls object
const stationControls = {};

// External THREE.js objects we need access to
// Don't redeclare these as they come from main.js
// let scene, camera, clock;

// station descriptions
const stationDescriptions = {
    pipeline: "The graphics pipeline is the sequence of steps used to create a 2D representation of a 3D scene. Major stages include vertex processing, primitive assembly, rasterization, and fragment processing.",
    lighting: "Lighting models simulate how light interacts with surfaces. Key concepts include ambient light, diffuse reflection, and specular reflection, as well as shadows and global illumination techniques.\n\nAmbient lighting simulates indirect light scattered throughout a scene, ensuring objects are never completely dark. It represents the effect of light bouncing off multiple surfaces, so even areas not directly lit by a light source remain visible.\n\nDiffuse reflection occurs when light hits a rough surface and is scattered equally in all directions. This gives objects their basic color and soft shading, and is characteristic of matte or non-shiny surfaces, often called Lambertian reflectors.\n\nSpecular reflection happens when light reflects off a smooth surface in a specific direction, creating a bright, concentrated highlight. The size and sharpness of this highlight depend on how smooth or shiny the material is-glossy surfaces produce small, sharp highlights, while duller surfaces create larger, softer ones.",
    texturing: "Texturing is a fundamental technique in computer graphics used to add detail, and realism to the surfaces of 2D and 3D objects. Instead of modeling each tiny feature geometrically, textures let programmers paint detailed images and patterns onto surfaces without increasing computational cost. Some important techniques used are Texture Mapping, and Procedural Texturing.\n\nTexture Mapping is the process of applying a 2D image to a 3D surface. Each vertex of a polygon is assigned a texture coordinate, and is the most common texturing technique.\n\nProcedural Texturing is when textures are generated by mathmatical functions. Generating textures this way allows for dynamic, scalable and memory efficient surface patterns. It's useful when you need textures at arbitrary resolutions",
    geometry: "Geometry in computer graphics involves representing and manipulating shapes in 2D and 3D spaces. Instead of working with each pixel individually, geometry lets programmers describe complex scenes using points, lines, and polygons, enabling efficient rendering. Some imporant techniques are vectors and polygons.\n\nVectors are directed line segments defined by their length and direction. Operations on vectors like the dot product and cross product are essential for calculating angles, and projections, which are fundamental in rendering and physics calculations. \n\nPolygons are sequences of vertices connected by edges, and are one of the basic building blocks used to model 3D objects.",
    shaders: "Shaders are special programs used in computer graphics that controls how surfaces and pixels are rendered, allowing effects like lighting, and shadows. Shaders run on the GPU and are essential for achieving realism, an important technique is Phong Shading. \n\nPhong Shading interpolates surface normals across a polygon and computes lighting for each pixel. Phong Shading results in more realistic lighting, and is a common technique used in computer graphics."
};

/**
 * Initialize the world with scene and camera references
 */
function initWorld(sceneRef, cameraRef) {
    // Use the existing scene and camera from main.js
    // We don't need to set scene and camera since they're already global
    
    // Create the world
    createWorld();
}

//=============================================================================
// MAIN WORLD FUNCTIONS
//=============================================================================

/**
 * Legacy function for backward compatibility 
 */
function createWorld() {
    if (!scene) {
        console.error('Scene not initialized! Call initWorld first.');
        return;
    }
    
    console.log('Creating Team 3 UTD Graphics Learning World...');
    
    // make skybox
    createSkybox();
    
    // setup ground
    createTerrain();
    
    // add learning stations
    createLearningStations();
    
    // add trees and decorations
    addWorldDecorations();

    // add world boundaries
    createWorldBorder();
    
    console.log('Team 3 UTD Graphics Learning World created successfully!');
}

/**
 * update world animations
 */
function updateWorld(time) {
    // Use a fixed delta time or get it from animation loop if passed as parameter
    const delta = 0.016; // Approximately 60fps

    // update all learning station demos
    for (const stationKey in learningStations) {
        const station = learningStations[stationKey];
        if (station.demoObject && station.demoObject.update && station.demoObject.visible) {
            station.demoObject.update(time, delta);
        }
    }
}

/**
 * check if player is near stations
 */
function checkStationProximity() {
    try {
        // get player position
        const playerPosition = camera.position;
        
        // check distance to each station
        let nearestStation = null;
        let nearestDistance = 5; // activation radius
        
        for (const stationKey in learningStations) {
            const station = learningStations[stationKey];
            const distance = playerPosition.distanceTo(station.position);
            
            if (distance < nearestDistance) {
                nearestDistance = distance;
                nearestStation = station;
            }
        }
        
        // activate nearest station, deactivate others
        if (nearestStation !== currentStation) {
            // deactivate current station
            if (currentStation) {
                currentStation.deactivate();
            }
            
            // activate new station
            if (nearestStation) {
                nearestStation.activate();
            } else {
                // no station nearby, reset UI
                const currentTopicElement = document.getElementById('current-topic');
                if (currentTopicElement) {
                    currentTopicElement.textContent = 'Explore';
                }
                
                const topicDescriptionElement = document.getElementById('topic-description');
                if (topicDescriptionElement) {
                    topicDescriptionElement.innerHTML = 
                        '<p>Move around the 3D world to discover learning stations about computer graphics concepts.</p>';
                }
                
                currentStation = null;
            }
        }
    } catch (error) {
        console.error('proximity check error:', error);
    }
}

//=============================================================================
// ENVIRONMENT CREATION
//=============================================================================

/**
 * Creates a skybox for the 3D world
 */
function createSkybox() {
    try {
        const loader = new THREE.CubeTextureLoader();
        loader.setPath('assets/textures/skybox/');
        
        // Placeholder for actual skybox textures
        // In a real implementation, you would have these files
        const skyboxTexture = loader.load([
            'px.jpg', 'nx.jpg',
            'py.jpg', 'ny.jpg',
            'pz.jpg', 'nz.jpg'
        ], 
        // Success callback
        undefined, 
        // Error callback
        function(err) {
            console.log('Error loading skybox textures, using fallback color');
            scene.background = new THREE.Color(0x88ccee);
        });
        
        scene.background = skyboxTexture;
    } catch (error) {
        console.log('Error creating skybox, using fallback color');
        scene.background = new THREE.Color(0x88ccee);
    }
}

/**
 * Creates the terrain for the 3D world
 */
function createTerrain() {
    console.log('Creating terrain');
    
    // Create a large ground plane
    const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
    
    // Default ground material (fallback)
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x567d46,
        roughness: 0.8,
        metalness: 0.2
    });
    
    // Try to load ground texture
    try {
        const textureLoader = new THREE.TextureLoader();
        textureLoader.setPath('assets/textures/');
        
        // Placeholder for actual ground textures
        // In a real implementation, you would have these files
        textureLoader.load('ground.jpg', 
            // Success callback
            function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
                groundMaterial.map = texture;
                groundMaterial.needsUpdate = true;
                console.log('Ground texture loaded successfully');
            },
            // Progress callback
            undefined,
            // Error callback
            function(err) {
                console.log('Error loading ground texture, using fallback color');
            }
        );
    } catch (error) {
        console.log('Error loading texture, using fallback color');
    }
    
    terrain = new THREE.Mesh(groundGeometry, groundMaterial);
    terrain.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    terrain.position.y = -1; // Raised position by 1 unit
    terrain.receiveShadow = true;
    scene.add(terrain);
    
    console.log('Terrain created at position:', terrain.position);
    
    // Add some terrain features like hills
    addTerrainFeatures();
}

/**
 * Adds features to the terrain like hills and valleys
 */
function addTerrainFeatures() {
    // Add some hills using simple geometries
    const hillGeometry = new THREE.ConeGeometry(10, 5, 16);
    const hillMaterial = new THREE.MeshStandardMaterial({
        color: 0x567d46,
        roughness: 0.9
    });
    
    // Create a few hills at different positions
    const hill1 = new THREE.Mesh(hillGeometry, hillMaterial);
    hill1.position.set(-30, -2, -20);
    hill1.scale.set(1, 0.5, 1);
    scene.add(hill1);
    
    const hill2 = new THREE.Mesh(hillGeometry, hillMaterial);
    hill2.position.set(25, -2, -15);
    hill2.scale.set(0.8, 0.6, 0.8);
    scene.add(hill2);
}

/**
 * Creates interactive learning stations throughout the 3D world
 */
function createLearningStations() {
    // Create the Pipeline Station
    learningStations.pipeline = createStation(
        'Pipeline', 
        new THREE.Vector3(-15, 0, -15),
        0x4CAF50
    );
    
    // Create the Lighting Station
    learningStations.lighting = createStation(
        'Lighting', 
        new THREE.Vector3(15, 0, -15),
        0xFFC107
    );
    
    // Create the Texturing Station
    learningStations.texturing = createStation(
        'Texturing', 
        new THREE.Vector3(-15, 0, 15),
        0x2196F3
    );
    
    // Create the Geometry Station
    learningStations.geometry = createStation(
        'Geometry', 
        new THREE.Vector3(15, 0, 15),
        0xE91E63
    );
    
    // Create the Shader Station
    learningStations.shaders = createStation(
        'Shaders', 
        new THREE.Vector3(0, 0, -25),
        0x9C27B0
    );
}

/**
 * Creates a single learning station with interactive elements
 * @param {string} name - The name of the station
 * @param {THREE.Vector3} position - The position in the 3D world
 * @param {number} color - The color of the station
 * @returns {Object} - The station object
 */
function createStation(name, position, color) {
    // Create a platform for the station
    const platformGeometry = new THREE.CylinderGeometry(5, 5, 0.5, 32);
    const platformMaterial = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.3,
        roughness: 0.5
    });
    
    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
    platform.position.copy(position);
    platform.position.y = -0.25; // Half height of platform
    platform.receiveShadow = true;
    scene.add(platform);
    
    // Create a holographic display
    const displayGeometry = new THREE.BoxGeometry(3, 4, 0.1);
    const displayMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: color,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.7
    });
    
    const display = new THREE.Mesh(displayGeometry, displayMaterial);
    display.position.copy(position);
    display.position.y = 2; // Height of display
    display.castShadow = false; // Explicitly set to false
    scene.add(display);
    
    // Create a floating name label
    const textMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff
    });
    
    // In a real implementation, you would use a TextGeometry
    // For now, we'll use a simple placeholder
    const labelGeometry = new THREE.PlaneGeometry(4, 0.8);
    const label = new THREE.Mesh(labelGeometry, textMaterial);
    label.position.copy(position);
    label.position.y = 4.5;
    scene.add(label);
    
    // Create a demo object specific to this station
    const demoObject = createStationDemoObject(name, position, color);
    
    // Return the station object with all its components
    return {
        name: name,
        position: position,
        platform: platform,
        display: display,
        label: label,
        demoObject: demoObject,
        
        // Method to activate this station
        activate: function() {
            // Highlight the platform
            platform.material.emissive = new THREE.Color(color);
            platform.material.emissiveIntensity = 0.5;
            
            // Get the description for this station
            const stationKey = name.toLowerCase();
            const description = stationDescriptions[stationKey] || 'Explore this station to learn about ' + name + '.';
            
            // Update UI with station info
            updateStationInfo(name, description);
            
            // Check if demo object exists before trying to use it
            if (this.demoObject) {
                try {
                    console.log('Activating demo for station:', name);
                    // Make demo object visible
                    this.demoObject.visible = true;
                    
                    // If the demo object has an init method (e.g., for resetting animation), call it
                    if (this.demoObject.init) {
                        this.demoObject.init();
                    }
                    
                    // Set up interactive controls if the demo supports it
                    if (stationControls[stationKey] && stationControls[stationKey].show) {
                        stationControls[stationKey].show();
                    } else {
                        console.warn('No controls available for station:', name);
                    }
                } catch (error) {
                    console.error('Error activating demo object:', error);
                }
            } else {
                console.error('No demo object available for station:', name);
            }
            
            // Set as current station
            currentStation = this;
        },
        
        // Method to deactivate this station
        deactivate: function() {
            // Remove highlight
            platform.material.emissiveIntensity = 0;
            
            // Check if demo object exists before trying to hide it
            if (this.demoObject) {
                try {
                    console.log('Deactivating demo for station:', name);
                    // Hide demo object
                    this.demoObject.visible = false;
                    
                    // Remove interactive controls if available
                    const stationKey = name.toLowerCase();
                    if (stationControls[stationKey] && stationControls[stationKey].hide) {
                        stationControls[stationKey].hide();
                    }
                } catch (error) {
                    console.error('Error deactivating demo object:', error);
                }
            }
        }
    };
}

//=============================================================================
// DEMO OBJECTS FOR STATIONS
//=============================================================================

/**
 * Creates a demo object based on station type
 */
function createStationDemoObject(stationType, position, color) {
    let demoObject = null;
    
    // Ensure we clean the station type for better matching
    const type = stationType.toLowerCase().trim();
    
    console.log('Creating station demo for type:', type);
    
    // First, match against exact name
    if (type === 'pipeline' || type === 'the pipeline' || type === 'graphics pipeline') {
        demoObject = createPipelineDemo(position, color);
    } 
    else if (type === 'lighting' || type === 'light' || type === 'lighting model') {
        demoObject = createLightingDemo(position, color);
    } 
    else if (type === 'texturing' || type === 'texture' || type === 'textures') {
        demoObject = createTexturingDemo(position, color);
    } 
    else if (type === 'geometry' || type === 'shapes' || type === 'geometric') {
        demoObject = createGeometryDemo(position, color);
    } 
    else if (type === 'shaders' || type === 'shader' || type === 'shading') {
        demoObject = createShaderDemo(position, color);
    }
    else {
        // Fallback to switch with exact matches only
        switch(type) {
            case 'pipeline':
                demoObject = createPipelineDemo(position, color);
                break;
            case 'lighting':
                demoObject = createLightingDemo(position, color);
                break;
            case 'texturing':
                demoObject = createTexturingDemo(position, color);
                break;
            case 'geometry':
                demoObject = createGeometryDemo(position, color);
                break;
            case 'shaders':
                demoObject = createShaderDemo(position, color);
                break;
            default:
                console.warn('Unknown station type:', stationType, 'Cleaned type:', type);
                // Create a fallback demo object
                const geometry = new THREE.SphereGeometry(1, 32, 32);
                const material = new THREE.MeshBasicMaterial({ color: color });
                demoObject = new THREE.Mesh(geometry, material);
                demoObject.position.copy(position);
                demoObject.position.y += 2;
                scene.add(demoObject);
        }
    }
    
    if (demoObject) {
        demoObject.visible = false; // Hidden by default
        scene.add(demoObject);
    }
    
    // If demoObject is null or doesn't have expected properties, create a placeholder
    if (!demoObject || typeof demoObject.update !== 'function') {
        console.warn('Creating placeholder for demo object:', stationType);
        // Create placeholder with update method
        const placeholderGroup = new THREE.Group();
        placeholderGroup.position.copy(position);
        placeholderGroup.position.y += 3;
        
        const placeholderGeometry = new THREE.SphereGeometry(1, 16, 16);
        const placeholderMaterial = new THREE.MeshBasicMaterial({ color: color });
        const placeholderMesh = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
        placeholderGroup.add(placeholderMesh);
        
        // Add update method to placeholder
        placeholderGroup.update = function(time, delta) {
            placeholderMesh.rotation.y += delta * 0.5;
        };
        
        placeholderGroup.visible = false;
        scene.add(placeholderGroup);
        demoObject = placeholderGroup;
    }
    
    return demoObject;
}

/**
 * Creates the pipeline demo object
 */
function createPipelineDemo(position, color) {
    // Create a group to hold all pipeline demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create stages of the pipeline as separate objects
    const stages = ['vertex', 'tessellation', 'geometry', 'rasterization', 'fragment', 'output'];
    const stageObjects = {};
    const stageSpacing = 0.7;
    
    // Create a 3D model that moves through the pipeline
    const pipelineModelGeometry = new THREE.TorusKnotGeometry(0.3, 0.1, 32, 8);
    const pipelineModelMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        emissive: color,
        emissiveIntensity: 0.5,
        wireframe: false
    });
    const pipelineModel = new THREE.Mesh(pipelineModelGeometry, pipelineModelMaterial);
    group.add(pipelineModel);
    
    // Create stage indicators
    stages.forEach((stage, index) => {
        const stageIndicatorGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const stageIndicatorMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            emissive: color,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.7
        });
        
        const stageIndicator = new THREE.Mesh(stageIndicatorGeometry, stageIndicatorMaterial);
        stageIndicator.position.x = (index - 2.5) * stageSpacing;
        stageIndicator.position.y = 0;
        stageObjects[stage] = stageIndicator;
        group.add(stageIndicator);
    });
    
    // Create control panel for pipeline demo
    const controlPanel = document.createElement('div');
    controlPanel.id = 'pipeline-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Pipeline Controls</h3>
        <div class="control-group">
            <h4>Current Stage</h4>
            <div class="button-group" style="display: flex; flex-wrap: wrap; gap: 5px;">
                <button id="stage-vertex" class="stage-button" style="flex: 1; min-width: 80px;">Vertex</button>
                <button id="stage-tessellation" class="stage-button" style="flex: 1; min-width: 80px;">Tessellation</button>
                <button id="stage-geometry" class="stage-button" style="flex: 1; min-width: 80px;">Geometry</button>
                <button id="stage-rasterization" class="stage-button" style="flex: 1; min-width: 80px;">Rasterization</button>
                <button id="stage-fragment" class="stage-button" style="flex: 1; min-width: 80px;">Fragment</button>
                <button id="stage-output" class="stage-button" style="flex: 1; min-width: 80px;">Output</button>
            </div>
        </div>
        <div class="control-group">
            <h4>Stage Description</h4>
            <div id="pipeline-stage-description" style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 5px; min-height: 80px;">
                Select a stage to see its description
            </div>
        </div>
        <div class="control-group">
            <h4>Animation Speed</h4>
            <input type="range" min="0.1" max="2" step="0.1" value="1" id="pipeline-speed-slider">
        </div>
        <div class="control-group">
            <h4>Wireframe Mode</h4>
            <button id="pipeline-wireframe-toggle">Toggle Wireframe</button>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add stage descriptions
    const stageDescriptions = {
        vertex: "Vertex Processing transforms 3D vertex positions into screen space coordinates. It handles per-vertex operations like transformations, skinning, and morphing.",
        tessellation: "Tessellation subdivides geometry into smaller primitives to add detail. It can dynamically increase mesh resolution based on distance or importance.",
        geometry: "Geometry Shading works with complete primitives, allowing creation or elimination of vertices. It can generate new geometry procedurally.",
        rasterization: "Rasterization converts vector data into pixels on the screen. It determines which pixels are covered by each primitive.",
        fragment: "Fragment Processing calculates the final color of each pixel. This includes texturing, lighting, shadows, reflections, and other visual effects.",
        output: "Output Merging combines the fragment data with the frame buffer. It handles depth testing, stencil operations, and blending."
    };

    // Add event listeners for the controls
    if (document.getElementById('pipeline-controls')) {
        // Stage buttons
        const stageButtons = document.querySelectorAll('#pipeline-controls .stage-button');
        stageButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Clear active state from all buttons
                stageButtons.forEach(btn => btn.style.background = 'rgba(255, 255, 255, 0.2)');
                
                // Set active state for clicked button
                this.style.background = 'rgba(255, 255, 255, 0.5)';
                
                const stageName = this.id.replace('stage-', '');
                console.log('Stage button clicked:', stageName);
                
                // Update description
                const descriptionElement = document.getElementById('pipeline-stage-description');
                if (descriptionElement) {
                    descriptionElement.textContent = stageDescriptions[stageName] || 'No description available';
                }
                
                // Call highlightStage to update the 3D model
                highlightStage(stageName);
            });
        });
        
        // Speed slider
        const speedSlider = document.getElementById('pipeline-speed-slider');
        speedSlider.addEventListener('input', function() {
            group.animationSpeed = parseFloat(this.value);
        });
        
        // Wireframe toggle
        const wireframeToggle = document.getElementById('pipeline-wireframe-toggle');
        wireframeToggle.addEventListener('click', function() {
            pipelineModelMaterial.wireframe = !pipelineModelMaterial.wireframe;
        });
    }
    
    // Function to highlight a specific stage
    function highlightStage(stageName) {
        console.log('Highlighting stage:', stageName);
        
        // Highlight the selected stage and dim others
        stages.forEach(stage => {
            if (stageObjects[stage]) {
                if (stage === stageName) {
                    // Make selected stage more prominent
                    stageObjects[stage].material.emissiveIntensity = 1.0;
                    stageObjects[stage].scale.set(1.5, 1.5, 1.5);
                    stageObjects[stage].material.opacity = 1.0;
                    
                    // Add a pulsing animation to the selected stage
                    const pulseAnimation = () => {
                        const time = Date.now() * 0.001;
                        const pulse = 0.8 + Math.sin(time * 3) * 0.2;
                        stageObjects[stage].scale.set(pulse * 1.5, pulse * 1.5, pulse * 1.5);
                        requestAnimationFrame(pulseAnimation);
                    };
                    
                    // Store the current animation frame ID
                    if (!stageObjects[stage].animationFrameId) {
                        stageObjects[stage].animationFrameId = requestAnimationFrame(pulseAnimation);
                    }
                } else {
                    // Reset non-selected stages
                    stageObjects[stage].material.emissiveIntensity = 0.2;
                    stageObjects[stage].scale.set(1, 1, 1);
                    stageObjects[stage].material.opacity = 0.7;
                    
                    // Cancel any existing animation
                    if (stageObjects[stage].animationFrameId) {
                        cancelAnimationFrame(stageObjects[stage].animationFrameId);
                        stageObjects[stage].animationFrameId = null;
                    }
                }
            }
        });
        
        // Update model appearance based on stage
        if (stageName === 'vertex') {
            pipelineModelMaterial.wireframe = true;
            pipelineModelMaterial.emissiveIntensity = 0.3;
            // Position model at this stage
            pipelineModel.position.x = (stages.indexOf('vertex') - 2.5) * stageSpacing;
        } else if (stageName === 'tessellation') {
            pipelineModelMaterial.wireframe = true;
            pipelineModelMaterial.emissiveIntensity = 0.5;
            // Position model at this stage
            pipelineModel.position.x = (stages.indexOf('tessellation') - 2.5) * stageSpacing;
        } else if (stageName === 'geometry') {
            pipelineModelMaterial.wireframe = true;
            pipelineModelMaterial.emissiveIntensity = 0.7;
            // Position model at this stage
            pipelineModel.position.x = (stages.indexOf('geometry') - 2.5) * stageSpacing;
        } else if (stageName === 'rasterization') {
            pipelineModelMaterial.wireframe = false;
            pipelineModelMaterial.emissiveIntensity = 0.3;
            // Position model at this stage
            pipelineModel.position.x = (stages.indexOf('rasterization') - 2.5) * stageSpacing;
        } else if (stageName === 'fragment') {
            pipelineModelMaterial.wireframe = false;
            pipelineModelMaterial.emissiveIntensity = 0.5;
            // Position model at this stage
            pipelineModel.position.x = (stages.indexOf('fragment') - 2.5) * stageSpacing;
        } else if (stageName === 'output') {
            pipelineModelMaterial.wireframe = false;
            pipelineModelMaterial.emissiveIntensity = 0.8;
            // Position model at this stage
            pipelineModel.position.x = (stages.indexOf('output') - 2.5) * stageSpacing;
        }
    }
    
    // Store controls reference for show/hide
    stationControls.pipeline = {
        show: function() {
            const controls = document.getElementById('pipeline-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('pipeline-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Set initial animation speed
    group.animationSpeed = 1.0;
    
    // Add animation update function
    group.update = function(time, delta) {
        // Animate based on time and speed
        const speed = this.animationSpeed || 1.0;
        const animTime = time * speed;
        
        // Move the model along the pipeline stages
        const position = (Math.sin(animTime * 0.5) + 1) / 2; // 0 to 1
        const stagePosition = position * (stages.length - 1); // 0 to stages.length-1
        const stageIndex = Math.min(Math.floor(stagePosition), stages.length - 1);
        
        // Position the model
        pipelineModel.position.x = (stagePosition - 2.5) * stageSpacing;
        
        // Rotate model as it moves
        pipelineModel.rotation.x += delta * 2;
        pipelineModel.rotation.y += delta * 3;
        
        // Highlight the current stage
        highlightStage(stages[stageIndex]);
    };
    
    // Return group without adding to scene
    return group;
}

/**
 * Creates the lighting demo object
 */
function createLightingDemo(position, color) {
    // Create a group to hold all lighting demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create a demo object to showcase lighting
    const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    const sphereMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.5,
        metalness: 0.2
    });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    group.add(sphere);
    
    // Create a point light for the demo
    const pointLight = new THREE.PointLight(0xFFFFFF, 1, 10);
    pointLight.position.set(2, 2, 2);
    group.add(pointLight);
    
    // Create a visual representation of the light
    const lightSphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const lightSphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF
    });
    const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
    lightSphere.position.copy(pointLight.position);
    group.add(lightSphere);
    
    // Add control panel
    const controlPanel = document.createElement('div');
    controlPanel.id = 'lighting-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Lighting Controls</h3>
        <div class="control-group">
            <h4>Light Color</h4>
            <div class="button-group" style="display: flex; flex-wrap: wrap; gap: 5px;">
                <button data-color="#FFFFFF" class="color-button" style="background-color: #FFFFFF; flex: 1; min-width: 80px; color: #000000; border: 2px solid #666666;">White</button>
                <button data-color="#FF9800" class="color-button" style="background-color: #FF9800; flex: 1; min-width: 80px;">Orange</button>
                <button data-color="#2196F3" class="color-button" style="background-color: #2196F3; flex: 1; min-width: 80px;">Blue</button>
                <button data-color="#E91E63" class="color-button" style="background-color: #E91E63; flex: 1; min-width: 80px;">Pink</button>
                <button data-color="#4CAF50" class="color-button" style="background-color: #4CAF50; flex: 1; min-width: 80px;">Green</button>
            </div>
        </div>
        <div class="control-group">
            <h4>Light Brightness</h4>
            <input type="range" min="0" max="2" step="0.1" value="1" id="brightness-slider">
        </div>
        <div class="control-group">
            <h4>Material Properties</h4>
            <div class="slider-group">
                <label>Shininess</label>
                <input type="range" min="0" max="1" step="0.1" value="0.5" id="shininess-slider">
            </div>
            <div class="slider-group">
                <label>Metalness</label>
                <input type="range" min="0" max="1" step="0.1" value="0.2" id="metalness-slider">
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add event listeners for the controls
    if (document.getElementById('lighting-controls')) {
        // Color buttons
        const colorButtons = document.querySelectorAll('#lighting-controls .color-button');
        colorButtons.forEach(button => {
            button.addEventListener('click', function() {
                const colorValue = this.getAttribute('data-color');
                pointLight.color.set(colorValue);
                lightSphere.material.color.set(colorValue);
            });
        });
        
        // Brightness slider
        const brightnessSlider = document.getElementById('brightness-slider');
        brightnessSlider.addEventListener('input', function() {
            pointLight.intensity = parseFloat(this.value);
        });
        
        // Material property sliders
        const shininessSlider = document.getElementById('shininess-slider');
        shininessSlider.addEventListener('input', function() {
            const roughness = 1 - parseFloat(this.value);
            sphereMaterial.roughness = roughness;
            sphereMaterial.needsUpdate = true;
        });
        
        const metalnessSlider = document.getElementById('metalness-slider');
        metalnessSlider.addEventListener('input', function() {
            sphereMaterial.metalness = parseFloat(this.value);
            sphereMaterial.needsUpdate = true;
        });
    }
    
    // Store controls reference for show/hide
    stationControls.lighting = {
        show: function() {
            const controls = document.getElementById('lighting-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('lighting-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Rotate light around sphere
        const angle = time * 0.5;
        const radius = 2;
        const height = Math.sin(time * 0.3) + 2;
        
        pointLight.position.x = Math.cos(angle) * radius;
        pointLight.position.y = height;
        pointLight.position.z = Math.sin(angle) * radius;
        
        lightSphere.position.copy(pointLight.position);
    };
    
    // Return group without adding to scene
    return group;
}

/**
 * Creates the texturing demo object
 */
function createTexturingDemo(position, color) {
    // Create a group to hold all texturing demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create a cube to showcase texturing
    const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
    const cubeMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.7,
        metalness: 0.2
    });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    group.add(cube);
    
    // Setup texture parameters
    let currentTexture = 'bricks';
    let textureRepeat = 1;
    let textureRotation = 0;
    
    // Generate procedural textures
    const textureSize = 512;
    const generateProceduralTexture = (type) => {
        const canvas = document.createElement('canvas');
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext('2d');
        
        // Clear canvas with white
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, textureSize, textureSize);
        
        switch (type) {
            case 'bricks':
                // Draw brick pattern
                const brickWidth = 60;
                const brickHeight = 30;
                const mortarSize = 5;
                
                ctx.fillStyle = '#A52A2A';
                
                for (let y = 0; y < textureSize; y += brickHeight + mortarSize) {
                    // Alternate brick rows
                    const offset = (Math.floor(y / (brickHeight + mortarSize)) % 2) * (brickWidth / 2);
                    
                    for (let x = -offset; x < textureSize; x += brickWidth + mortarSize) {
                        ctx.fillRect(x, y, brickWidth, brickHeight);
                    }
                }
                break;
                
            case 'wood':
                // Draw wood grain pattern
                const baseColor = '#8B4513';
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, textureSize, textureSize);
                
                // Add wood grain
                ctx.strokeStyle = '#603311';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * textureSize;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    
                    // Create wavy line
                    for (let y = 0; y < textureSize; y += 10) {
                        const xOffset = x + Math.sin(y * 0.05) * 5 + Math.random() * 3;
                        ctx.lineTo(xOffset, y);
                    }
                    
                    ctx.stroke();
                }
                break;
                
            case 'stone':
                // Draw stone pattern
                ctx.fillStyle = '#888888';
                ctx.fillRect(0, 0, textureSize, textureSize);
                
                // Add stone pattern
                for (let i = 0; i < 50; i++) {
                    const size = 20 + Math.random() * 40;
                    const x = Math.random() * textureSize;
                    const y = Math.random() * textureSize;
                    const shade = 100 + Math.floor(Math.random() * 100);
                    
                    ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add cracks
                ctx.strokeStyle = '#555555';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * textureSize;
                    const y = Math.random() * textureSize;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    
                    // Create random crack
                    let currentX = x;
                    let currentY = y;
                    const segments = 5 + Math.floor(Math.random() * 5);
                    
                    for (let j = 0; j < segments; j++) {
                        currentX += (Math.random() - 0.5) * 40;
                        currentY += (Math.random() - 0.5) * 40;
                        ctx.lineTo(currentX, currentY);
                    }
                    
                    ctx.stroke();
                }
                break;
                
            case 'checkerboard':
                // Draw checkerboard pattern
                const squareSize = 64;
                
                for (let y = 0; y < textureSize; y += squareSize) {
                    for (let x = 0; x < textureSize; x += squareSize) {
                        const isEven = (Math.floor(x / squareSize) + Math.floor(y / squareSize)) % 2 === 0;
                        ctx.fillStyle = isEven ? '#000000' : '#FFFFFF';
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }
                break;
                
            case 'dots':
                // Draw dot pattern
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, textureSize, textureSize);
                
                const dotSize = 10;
                const spacing = 40;
                
                ctx.fillStyle = '#000000';
                
                for (let y = spacing / 2; y < textureSize; y += spacing) {
                    for (let x = spacing / 2; x < textureSize; x += spacing) {
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                break;
                
            default:
                // Default pattern
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, textureSize, textureSize);
        }
        
        return new THREE.CanvasTexture(canvas);
    };
    
    // Apply texture to the cube
    const applyTexture = (textureType) => {
        currentTexture = textureType;
        
        const texture = generateProceduralTexture(textureType);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(textureRepeat, textureRepeat);
        texture.rotation = textureRotation;
        
        cubeMaterial.map = texture;
        cubeMaterial.needsUpdate = true;
    };
    
    // Initially apply brick texture
    applyTexture('bricks');
    
    // Add texture control panel
    const controlPanel = document.createElement('div');
    controlPanel.id = 'texturing-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Texture Controls</h3>
        <div class="control-group">
            <h4>Texture Type</h4>
            <div class="button-group">
                <button data-texture="bricks" class="texture-button">Bricks</button>
                <button data-texture="wood" class="texture-button">Wood</button>
                <button data-texture="stone" class="texture-button">Stone</button>
                <button data-texture="checkerboard" class="texture-button">Checkers</button>
                <button data-texture="dots" class="texture-button">Dots</button>
            </div>
        </div>
        <div class="control-group">
            <h4>Texture Repeat</h4>
            <input type="range" min="0.5" max="5" step="0.5" value="1" id="repeat-slider">
        </div>
        <div class="control-group">
            <h4>Texture Rotation</h4>
            <div class="button-group">
                <button id="rotate-left">⟲ Rotate Left</button>
                <button id="rotate-right">⟳ Rotate Right</button>
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add event listeners for the controls
    if (document.getElementById('texturing-controls')) {
        // Texture type buttons
        const textureButtons = document.querySelectorAll('#texturing-controls .texture-button');
        textureButtons.forEach(button => {
            button.addEventListener('click', function() {
                const textureType = this.getAttribute('data-texture');
                applyTexture(textureType);
            });
        });
        
        // Repeat slider
        const repeatSlider = document.getElementById('repeat-slider');
        repeatSlider.addEventListener('input', function() {
            textureRepeat = parseFloat(this.value);
            if (cubeMaterial.map) {
                cubeMaterial.map.repeat.set(textureRepeat, textureRepeat);
                cubeMaterial.needsUpdate = true;
            }
        });
        
        // Rotation buttons
        const rotateLeftButton = document.getElementById('rotate-left');
        rotateLeftButton.addEventListener('click', function() {
            textureRotation -= Math.PI / 6;
            if (cubeMaterial.map) {
                cubeMaterial.map.rotation = textureRotation;
                cubeMaterial.needsUpdate = true;
            }
        });
        
        const rotateRightButton = document.getElementById('rotate-right');
        rotateRightButton.addEventListener('click', function() {
            textureRotation += Math.PI / 6;
            if (cubeMaterial.map) {
                cubeMaterial.map.rotation = textureRotation;
                cubeMaterial.needsUpdate = true;
            }
        });
    }
    
    // Store controls reference for show/hide
    stationControls.texturing = {
        show: function() {
            const controls = document.getElementById('texturing-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('texturing-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Rotate cube slowly
        cube.rotation.y += delta * 0.2;
    };
    
    // Return group without adding to scene
    return group;
}

/**
 * Creates the geometry demo object
 */
function createGeometryDemo(position, color) {
    // Create a group to hold all geometry demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create different types of geometries
    const geometryTypes = {
        box: new THREE.BoxGeometry(1, 1, 1),
        sphere: new THREE.SphereGeometry(0.7, 32, 32),
        torus: new THREE.TorusGeometry(0.7, 0.3, 16, 100),
        cone: new THREE.ConeGeometry(0.7, 1.2, 32),
        cylinder: new THREE.CylinderGeometry(0.6, 0.6, 1.4, 32)
    };
    
    // Use a shared material for all geometries
    const geometryMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.5,
        metalness: 0.2
    });
    
    // Create the initial mesh with a box geometry
    const mesh = new THREE.Mesh(geometryTypes.box, geometryMaterial);
    group.add(mesh);
    
    // Variables to track current settings
    let currentGeometry = 'box';
    let wireframeEnabled = false;
    let subdivisionLevel = 0;
    
    // Add control panel for geometry demo
    const controlPanel = document.createElement('div');
    controlPanel.id = 'geometry-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Geometry Controls</h3>
        <div class="control-group">
            <h4>Geometry Type</h4>
            <div class="button-group" style="display: flex; flex-wrap: wrap; gap: 5px;">
                <button id="geom-box" class="geom-button" style="flex: 1; min-width: 80px;">Box</button>
                <button id="geom-sphere" class="geom-button" style="flex: 1; min-width: 80px;">Sphere</button>
                <button id="geom-torus" class="geom-button" style="flex: 1; min-width: 80px;">Torus</button>
                <button id="geom-cone" class="geom-button" style="flex: 1; min-width: 80px;">Cone</button>
                <button id="geom-cylinder" class="geom-button" style="flex: 1; min-width: 80px;">Cylinder</button>
            </div>
        </div>
        <div class="control-group">
            <h4>Geometry Description</h4>
            <div id="geometry-description" style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 5px; min-height: 80px;">
                Select a geometry type to see its description
            </div>
        </div>
        <div class="control-group">
            <h4>Rendering Mode</h4>
            <button id="geom-wireframe-toggle">Toggle Wireframe</button>
        </div>
        <div class="control-group">
            <h4>Material Properties</h4>
            <div class="slider-group">
                <label>Roughness</label>
                <input type="range" min="0" max="1" step="0.1" value="0.5" id="geom-roughness-slider">
            </div>
            <div class="slider-group">
                <label>Metalness</label>
                <input type="range" min="0" max="1" step="0.1" value="0.2" id="geom-metalness-slider">
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Define geometry descriptions
    const geometryDescriptions = {
        box: "Box (Cube) geometry is defined by width, height, and depth parameters. It's constructed from 6 faces, 8 vertices, and 12 triangles. Commonly used for buildings, containers, and architectural elements.",
        sphere: "Sphere geometry is defined by radius and detail level parameters. Higher segment counts create smoother spheres at the cost of performance. Ideal for planets, balls, and rounded objects.",
        torus: "Torus (Donut) geometry is created from two radii: the tube radius and the distance from the center to the tube. Common in mathematical visualization and decorative elements.",
        cone: "Cone geometry consists of a circular base that tapers to a point. Defined by radius and height parameters. Used for mountains, funnels, and directional indicators.",
        cylinder: "Cylinder geometry has consistent radius along its height. Defined by top radius, bottom radius, and height. Often used for pillars, tubes, and cylindrical containers."
    };

    // Add event listeners for the controls
    if (document.getElementById('geometry-controls')) {
        // Geometry type buttons
        const geomButtons = document.querySelectorAll('#geometry-controls .geom-button');
        geomButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Clear active state from all buttons
                geomButtons.forEach(btn => btn.style.background = 'rgba(255, 255, 255, 0.2)');
                
                // Set active state for clicked button
                this.style.background = 'rgba(255, 255, 255, 0.5)';
                
                const geomType = this.id.replace('geom-', '');
                console.log('Geometry type selected:', geomType);
                
                // Update the description
                const descriptionElement = document.getElementById('geometry-description');
                if (descriptionElement) {
                    descriptionElement.textContent = geometryDescriptions[geomType] || 'No description available';
                }
                
                // Change the geometry type
                changeGeometry(geomType);
            });
        });
        
        // Wireframe toggle
        const wireframeToggle = document.getElementById('geom-wireframe-toggle');
        wireframeToggle.addEventListener('click', function() {
            wireframeEnabled = !wireframeEnabled;
            geometryMaterial.wireframe = wireframeEnabled;
        });
        
        // Material property sliders
        const roughnessSlider = document.getElementById('geom-roughness-slider');
        roughnessSlider.addEventListener('input', function() {
            geometryMaterial.roughness = parseFloat(this.value);
            geometryMaterial.needsUpdate = true;
        });
        
        const metalnessSlider = document.getElementById('geom-metalness-slider');
        metalnessSlider.addEventListener('input', function() {
            geometryMaterial.metalness = parseFloat(this.value);
            geometryMaterial.needsUpdate = true;
        });
    }
    
    // Function to change the geometry type
    function changeGeometry(type) {
        if (geometryTypes[type]) {
            currentGeometry = type;
            mesh.geometry = geometryTypes[type];
        }
    }
    
    // Store controls reference for show/hide
    stationControls.geometry = {
        show: function() {
            const controls = document.getElementById('geometry-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('geometry-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Rotate the mesh
        mesh.rotation.y += delta * 0.5;
        mesh.rotation.x += delta * 0.2;
    };
    
    // Return group without adding to scene
    return group;
}

/**
 * Creates the shader demo object
 */
function createShaderDemo(position, color) {
    // Create a group to hold all shader demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create custom shader material
    const vertexShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;
    
    const fragmentShader = `
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float waveFrequency;
        uniform float waveAmplitude;
        uniform float blendFactor;
        
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
            // Create a more distinctive wave pattern
            float wave = sin(vUv.x * waveFrequency + time) * sin(vUv.y * waveFrequency + time) * waveAmplitude;
            
            // Make color2 more prominent by adjusting the blend factor
            // This ensures a more balanced mix between color1 and color2
            vec3 mixedColor = mix(color1, color2, (wave * blendFactor + 0.5));
            
            gl_FragColor = vec4(mixedColor, 1.0);
        }
    `;
    
    // Initial shader parameters
    const shaderUniforms = {
        time: { value: 0 },
        color1: { value: new THREE.Color(0x2196F3) },
        color2: { value: new THREE.Color(0xFF9800) },
        waveFrequency: { value: 10.0 },
        waveAmplitude: { value: 0.5 },
        blendFactor: { value: 1.0 }
    };
    
    const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: shaderUniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.DoubleSide
    });
    
    // Create a plane to display the shader
    const planeGeometry = new THREE.PlaneGeometry(2, 2, 32, 32);
    const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
    group.add(plane);
    
    // Add shader control panel
    const controlPanel = document.createElement('div');
    controlPanel.id = 'shader-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Shader Controls</h3>
        <div class="control-group">
            <h4>Colors</h4>
            <div class="color-control">
                <label>Color 1</label>
                <div class="button-group">
                    <button data-target="color1" data-color="#2196F3" class="color-button" style="background-color: #2196F3;"></button>
                    <button data-target="color1" data-color="#F44336" class="color-button" style="background-color: #F44336;"></button>
                    <button data-target="color1" data-color="#4CAF50" class="color-button" style="background-color: #4CAF50;"></button>
                </div>
            </div>
            <div class="color-control">
                <label>Color 2</label>
                <div class="button-group">
                    <button data-target="color2" data-color="#FF9800" class="color-button" style="background-color: #FF9800;"></button>
                    <button data-target="color2" data-color="#9C27B0" class="color-button" style="background-color: #9C27B0;"></button>
                    <button data-target="color2" data-color="#FFEB3B" class="color-button" style="background-color: #FFEB3B;"></button>
                </div>
            </div>
        </div>
        <div class="control-group">
            <h4>Wave Pattern</h4>
            <div class="slider-group">
                <label>Frequency</label>
                <input type="range" min="1" max="30" step="1" value="10" id="frequency-slider">
            </div>
            <div class="slider-group">
                <label>Amplitude</label>
                <input type="range" min="0" max="1" step="0.1" value="0.5" id="amplitude-slider">
            </div>
        </div>
        <div class="control-group">
            <h4>Blend Settings</h4>
            <div class="slider-group">
                <label>Blend Factor</label>
                <input type="range" min="0" max="1" step="0.1" value="1.0" id="blend-slider">
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add event listeners for the controls
    if (document.getElementById('shader-controls')) {
        // Single event handler for all color buttons
        const colorButtons = document.querySelectorAll('#shader-controls .color-button');
        colorButtons.forEach(button => {
            button.addEventListener('click', function() {
                const colorValue = this.getAttribute('data-color');
                const targetColor = this.getAttribute('data-target');
                
                // Set the right uniform based on the button's data-target attribute
                if (targetColor === 'color1') {
                    shaderUniforms.color1.value.set(colorValue);
                    console.log('Color 1 changed to:', colorValue);
                } else if (targetColor === 'color2') {
                    shaderUniforms.color2.value.set(colorValue);
                    console.log('Color 2 changed to:', colorValue);
                }
            });
        });
        
        // Frequency slider
        const frequencySlider = document.getElementById('frequency-slider');
        frequencySlider.addEventListener('input', function() {
            shaderUniforms.waveFrequency.value = parseFloat(this.value);
        });
        
        // Amplitude slider
        const amplitudeSlider = document.getElementById('amplitude-slider');
        amplitudeSlider.addEventListener('input', function() {
            shaderUniforms.waveAmplitude.value = parseFloat(this.value);
        });
        
        // Blend factor slider
        const blendSlider = document.getElementById('blend-slider');
        blendSlider.addEventListener('input', function() {
            shaderUniforms.blendFactor.value = parseFloat(this.value);
        });
    }
    
    // Store controls reference for show/hide
    stationControls.shaders = {
        show: function() {
            const controls = document.getElementById('shader-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('shader-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Update shader time uniform
        shaderUniforms.time.value = time;
        
        // Rotate plane slowly
        plane.rotation.y += delta * 0.2;
    };
    
    // Return group without adding to scene
    return group;
}

/**
 * Adds decorative elements to the world
 */
function addWorldDecorations() {
    // Add trees around the world
    addTrees();
    
    // Add particle effects
    addParticles();
}

/**
 * Adds trees throughout the world for decoration
 */
function addTrees() {
    // Create trees at various positions
    for (let i = 0; i < 20; i++) {
        const x = (Math.random() - 0.5) * 80;
        const z = (Math.random() - 0.5) * 80;
        
        // Don't place trees too close to stations
        let tooClose = false;
        for (const stationKey in learningStations) {
            const station = learningStations[stationKey];
            const dx = station.position.x - x;
            const dz = station.position.z - z;
            const distSquared = dx*dx + dz*dz;
            
            if (distSquared < 100) { // 10 units radius
                tooClose = true;
                break;
            }
        }
        
        if (!tooClose) {
            createTree(x, z);
        }
    }
}

/**
 * Creates a tree at the specified position
 */
function createTree(x, z) {
    // Create trunk
    const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({
        color: 0x8B4513,
        roughness: 0.9
    });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(x, 1, z);
    trunk.castShadow = true;
    scene.add(trunk);
    
    // Create foliage (leaves)
    const foliageGeometry = new THREE.ConeGeometry(2, 5, 8);
    const foliageMaterial = new THREE.MeshStandardMaterial({
        color: 0x2E8B57,
        roughness: 0.8
    });
    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
    foliage.position.set(x, 4, z);
    foliage.castShadow = true;
    scene.add(foliage);
}

/**
 * Adds particle effects to the world
 */
function addParticles() {
    // Create particles for atmospheric effect
    const particleCount = 1000;
    const particles = new THREE.BufferGeometry();
    
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        // Position particles randomly within a large cube
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 20;  // Height up to 20 units
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        // Give particles a slight blue-white color
        colors[i * 3] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 2] = 0.9 + Math.random() * 0.1;
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 0.5
    });
    
    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);
}

/**
 * Creates a world border to prevent players from leaving the area
 */
function createWorldBorder() {
    const wallHeight = 10;
    const worldSize = 50;
    const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x888888,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    // Create four walls
    const walls = [
        // North wall
        { pos: [0, wallHeight/2 - 1, -worldSize], size: [worldSize*2, wallHeight, 0.5] },
        // South wall
        { pos: [0, wallHeight/2 - 1, worldSize], size: [worldSize*2, wallHeight, 0.5] },
        // East wall
        { pos: [worldSize, wallHeight/2 - 1, 0], size: [0.5, wallHeight, worldSize*2] },
        // West wall
        { pos: [-worldSize, wallHeight/2 - 1, 0], size: [0.5, wallHeight, worldSize*2] }
    ];
    
    walls.forEach(wall => {
        const geometry = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
        const mesh = new THREE.Mesh(geometry, wallMaterial);
        mesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
        mesh.receiveShadow = true;
        scene.add(mesh);
    });
}

// Ensure functions are properly exposed to the global scope
console.log('World.js loaded, checking function availability');
if (typeof createWorld !== 'function') {
    console.error('createWorld function is not properly defined in the global scope');
    // Try to explicitly expose it
    window.createWorld = createWorld;
    window.initWorld = initWorld;
    window.createSkybox = createSkybox;
    window.createTerrain = createTerrain;
    window.checkStationProximity = checkStationProximity;
    window.updateWorld = updateWorld;
    console.log('Functions explicitly exposed to window object');
} else {
    console.log('createWorld function is properly defined in the global scope');
} 