/**
 * 3d world for graphics learning studio
 * handles terrain, stations, and interactive elements
 */

//=============================================================================
// GLOBAL VARIABLES AND CONSTANTS
//=============================================================================

// world objects
let terrain, skybox;
let learningStations = {};
let currentStation = null;

// Initialize station controls object
const stationControls = {};

// External THREE.js objects we need access to
let scene, camera, clock;

// station descriptions
const stationDescriptions = {
    pipeline: "The graphics pipeline is the sequence of steps used to create a 2D representation of a 3D scene. Major stages include vertex processing, primitive assembly, rasterization, and fragment processing.",
    lighting: "Lighting models simulate how light interacts with surfaces. Key concepts include ambient light, diffuse reflection, and specular reflection, as well as shadows and global illumination techniques.\n\nAmbient lighting simulates indirect light scattered throughout a scene, ensuring objects are never completely dark. It represents the effect of light bouncing off multiple surfaces, so even areas not directly lit by a light source remain visible.\n\nDiffuse reflection occurs when light hits a rough surface and is scattered equally in all directions. This gives objects their basic color and soft shading, and is characteristic of matte or non-shiny surfaces, often called Lambertian reflectors.\n\nSpecular reflection happens when light reflects off a smooth surface in a specific direction, creating a bright, concentrated highlight. The size and sharpness of this highlight depend on how smooth or shiny the material is-glossy surfaces produce small, sharp highlights, while duller surfaces create larger, softer ones.",
    texturing: "Texturing is a fundamental technique in computer graphics used to add detail, and realism to the surfaces of 2D and 3D objects. Instead of modeling each tiny feature geometrically, textures let programmers paint detailed images and patterns onto surfaces without increasing computational cost. Some important techniques used are Texture Mapping, and Procedural Texturing.\n\nTexture Mapping is the process of applying a 2D image to a 3D surface. Each vertex of a polygon is assigned a texture coordinate, and is the most common texturing technique.\n\nProcedural Texturing is when textures are generated by mathmatical functions. Generating textures this way allows for dynamic, scalable and memory efficient surface patterns. It's useful when you need textures at arbitrary resolutions",
    geometry: "Geometry in computer graphics involves creating and manipulating 3D shapes. This includes mesh representation, subdivision surfaces, and procedural geometry generation.",
    shaders: "Shaders are programs that run on the GPU to determine how objects are rendered. They control vertex positions, lighting calculations, and pixel colors."
};

/**
 * Initialize the world with scene and camera references
 */
function initWorld(sceneRef, cameraRef) {
    scene = sceneRef;
    camera = cameraRef;
    clock = new THREE.Clock();
    
    // Create the world
    createWorld();
}

//=============================================================================
// MAIN WORLD FUNCTIONS
//=============================================================================

/**
 * create main world environment
 */
function createWorld() {
    // make skybox
    createSkybox();
    
    // setup ground
    createTerrain();
    
    // add learning stations
    createLearningStations();
    
    // add trees and decorations
    addWorldDecorations();

    // add world boundaries
    createWorldBorder();
}

/**
 * update world animations
 */
function updateWorld(time) {
    const delta = clock.getDelta();

    // update all learning station demos
    for (const stationKey in learningStations) {
        const station = learningStations[stationKey];
        if (station.demoObject && station.demoObject.update && station.demoObject.visible) {
            station.demoObject.update(time, delta);
        }
    }
}

/**
 * check if player is near stations
 */
function checkStationProximity() {
    try {
        // get player position
        const playerPosition = camera.position;
        
        // check distance to each station
        let nearestStation = null;
        let nearestDistance = 5; // activation radius
        
        for (const stationKey in learningStations) {
            const station = learningStations[stationKey];
            const distance = playerPosition.distanceTo(station.position);
            
            if (distance < nearestDistance) {
                nearestDistance = distance;
                nearestStation = station;
            }
        }
        
        // activate nearest station, deactivate others
        if (nearestStation !== currentStation) {
            // deactivate current station
            if (currentStation) {
                currentStation.deactivate();
            }
            
            // activate new station
            if (nearestStation) {
                nearestStation.activate();
            } else {
                // no station nearby, reset UI
                const currentTopicElement = document.getElementById('current-topic');
                if (currentTopicElement) {
                    currentTopicElement.textContent = 'Explore';
                }
                
                const topicDescriptionElement = document.getElementById('topic-description');
                if (topicDescriptionElement) {
                    topicDescriptionElement.innerHTML = 
                        '<p>Move around the 3D world to discover learning stations about computer graphics concepts.</p>';
                }
                
                currentStation = null;
            }
        }
    } catch (error) {
        console.error('proximity check error:', error);
    }
}

//=============================================================================
// ENVIRONMENT CREATION
//=============================================================================

/**
 * Creates a skybox for the 3D world
 */
function createSkybox() {
    try {
        const loader = new THREE.CubeTextureLoader();
        loader.setPath('assets/textures/skybox/');
        
        // Placeholder for actual skybox textures
        // In a real implementation, you would have these files
        const skyboxTexture = loader.load([
            'px.jpg', 'nx.jpg',
            'py.jpg', 'ny.jpg',
            'pz.jpg', 'nz.jpg'
        ], 
        // Success callback
        undefined, 
        // Error callback
        function(err) {
            console.log('Error loading skybox textures, using fallback color');
            scene.background = new THREE.Color(0x88ccee);
        });
        
        scene.background = skyboxTexture;
    } catch (error) {
        console.log('Error creating skybox, using fallback color');
        scene.background = new THREE.Color(0x88ccee);
    }
}

/**
 * Creates the terrain for the 3D world
 */
function createTerrain() {
    console.log('Creating terrain');
    
    // Create a large ground plane
    const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
    
    // Default ground material (fallback)
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x567d46,
        roughness: 0.8,
        metalness: 0.2
    });
    
    // Try to load ground texture
    try {
        const textureLoader = new THREE.TextureLoader();
        textureLoader.setPath('assets/textures/');
        
        // Placeholder for actual ground textures
        // In a real implementation, you would have these files
        textureLoader.load('ground.jpg', 
            // Success callback
            function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
                groundMaterial.map = texture;
                groundMaterial.needsUpdate = true;
                console.log('Ground texture loaded successfully');
            },
            // Progress callback
            undefined,
            // Error callback
            function(err) {
                console.log('Error loading ground texture, using fallback color');
            }
        );
    } catch (error) {
        console.log('Error loading texture, using fallback color');
    }
    
    terrain = new THREE.Mesh(groundGeometry, groundMaterial);
    terrain.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    terrain.position.y = -1; // Raised position by 1 unit
    terrain.receiveShadow = true;
    scene.add(terrain);
    
    console.log('Terrain created at position:', terrain.position);
    
    // Add some terrain features like hills
    addTerrainFeatures();
}

/**
 * Adds features to the terrain like hills and valleys
 */
function addTerrainFeatures() {
    // Add some hills using simple geometries
    const hillGeometry = new THREE.ConeGeometry(10, 5, 16);
    const hillMaterial = new THREE.MeshStandardMaterial({
        color: 0x567d46,
        roughness: 0.9
    });
    
    // Create a few hills at different positions
    const hill1 = new THREE.Mesh(hillGeometry, hillMaterial);
    hill1.position.set(-30, -2, -20);
    hill1.scale.set(1, 0.5, 1);
    scene.add(hill1);
    
    const hill2 = new THREE.Mesh(hillGeometry, hillMaterial);
    hill2.position.set(25, -2, -15);
    hill2.scale.set(0.8, 0.6, 0.8);
    scene.add(hill2);
}

/**
 * Creates interactive learning stations throughout the 3D world
 */
function createLearningStations() {
    // Create the Pipeline Station
    learningStations.pipeline = createStation(
        'Pipeline', 
        new THREE.Vector3(-15, 0, -15),
        0x4CAF50
    );
    
    // Create the Lighting Station
    learningStations.lighting = createStation(
        'Lighting', 
        new THREE.Vector3(15, 0, -15),
        0xFFC107
    );
    
    // Create the Texturing Station
    learningStations.texturing = createStation(
        'Texturing', 
        new THREE.Vector3(-15, 0, 15),
        0x2196F3
    );
    
    // Create the Geometry Station
    learningStations.geometry = createStation(
        'Geometry', 
        new THREE.Vector3(15, 0, 15),
        0xE91E63
    );
    
    // Create the Shader Station
    learningStations.shaders = createStation(
        'Shaders', 
        new THREE.Vector3(0, 0, -25),
        0x9C27B0
    );
}

/**
 * Creates a single learning station with interactive elements
 * @param {string} name - The name of the station
 * @param {THREE.Vector3} position - The position in the 3D world
 * @param {number} color - The color of the station
 * @returns {Object} - The station object
 */
function createStation(name, position, color) {
    // Create a platform for the station
    const platformGeometry = new THREE.CylinderGeometry(5, 5, 0.5, 32);
    const platformMaterial = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.3,
        roughness: 0.5
    });
    
    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
    platform.position.copy(position);
    platform.position.y = -0.25; // Half height of platform
    platform.receiveShadow = true;
    scene.add(platform);
    
    // Create a holographic display
    const displayGeometry = new THREE.BoxGeometry(3, 4, 0.1);
    const displayMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: color,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.7
    });
    
    const display = new THREE.Mesh(displayGeometry, displayMaterial);
    display.position.copy(position);
    display.position.y = 2; // Height of display
    display.castShadow = false; // Explicitly set to false
    scene.add(display);
    
    // Create a floating name label
    const textMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff
    });
    
    // In a real implementation, you would use a TextGeometry
    // For now, we'll use a simple placeholder
    const labelGeometry = new THREE.PlaneGeometry(4, 0.8);
    const label = new THREE.Mesh(labelGeometry, textMaterial);
    label.position.copy(position);
    label.position.y = 4.5;
    scene.add(label);
    
    // Create a demo object specific to this station
    const demoObject = createStationDemoObject(name, position, color);
    
    // Return the station object with all its components
    return {
        name: name,
        position: position,
        platform: platform,
        display: display,
        label: label,
        demoObject: demoObject,
        
        // Method to activate this station
        activate: function() {
            // Highlight the platform
            platform.material.emissive = new THREE.Color(color);
            platform.material.emissiveIntensity = 0.5;
            
            // Get the description for this station
            const stationKey = name.toLowerCase();
            const description = stationDescriptions[stationKey] || 'Explore this station to learn about ' + name + '.';
            
            // Update UI with station info
            updateStationInfo(name, description);
            
            // Animate the demo object
            this.demoObject.visible = true;
            // If the demo object has an init method (e.g., for resetting animation), call it
            if (this.demoObject.init) {
                this.demoObject.init();
            }
            
            // Set up interactive controls if the demo supports it
            if (this.demoObject.setupControls) {
                this.demoObject.setupControls();
            }
            
            // Set as current station
            currentStation = this;
        },
        
        // Method to deactivate this station
        deactivate: function() {
            // Remove highlight
            platform.material.emissiveIntensity = 0;
            
            // Hide demo object
            this.demoObject.visible = false;
            
            // Remove interactive controls if the demo supports it
            if (this.demoObject.removeControls) {
                this.demoObject.removeControls();
            }
        }
    };
}

//=============================================================================
// DEMO OBJECTS FOR STATIONS
//=============================================================================

/**
 * Creates a demo object based on station type
 */
function createStationDemoObject(stationType, position, color) {
    let demoObject = null;
    
    switch(stationType) {
        case 'pipeline':
            demoObject = createPipelineDemo(position, color);
            break;
        case 'lighting':
            demoObject = createLightingDemo(position, color);
            break;
        case 'texturing':
            demoObject = createTexturingDemo(position, color);
            break;
        case 'geometry':
            demoObject = createGeometryDemo(position, color);
            break;
        case 'shaders':
            demoObject = createShaderDemo(position, color);
            break;
        default:
            console.error('Unknown station type:', stationType);
    }
    
    if (demoObject) {
        demoObject.visible = false; // Hidden by default
        scene.add(demoObject);
    }
    
    return demoObject;
}

/**
 * Creates the pipeline demo object
 */
function createPipelineDemo(position, color) {
    // Create a group to hold all pipeline demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create a simplistic representation of the pipeline
    const stages = [
        { name: "Vertex Processing", color: 0x4CAF50 },
        { name: "Primitive Assembly", color: 0x8BC34A },
        { name: "Rasterization", color: 0xCDDC39 },
        { name: "Fragment Processing", color: 0xFFEB3B },
        { name: "Output Merger", color: 0xFFC107 }
    ];
    
    const stageSpacing = 1.0;
    const stageSize = 0.5;
    
    // Create a model that will move through the pipeline
    const modelGeometry = new THREE.TetrahedronGeometry(0.3);
    const modelMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.5,
        metalness: 0.5
    });
    const model = new THREE.Mesh(modelGeometry, modelMaterial);
    model.position.set(-stageSpacing * 3, 0, 0);
    group.add(model);
    
    // Create visual representations of each pipeline stage
    for (let i = 0; i < stages.length; i++) {
        const stage = stages[i];
        
        // Create stage node
        const nodeGeometry = new THREE.BoxGeometry(stageSize, stageSize, stageSize);
        const nodeMaterial = new THREE.MeshStandardMaterial({
            color: stage.color,
            roughness: 0.7,
            metalness: 0.3
        });
        const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
        node.position.x = -stageSpacing * 2 + i * stageSpacing;
        group.add(node);
        
        // Create connection to next stage
        if (i < stages.length - 1) {
            const connectionGeometry = new THREE.CylinderGeometry(0.05, 0.05, stageSpacing, 8);
            const connectionMaterial = new THREE.MeshStandardMaterial({
                color: 0xBDBDBD
            });
            const connection = new THREE.Mesh(connectionGeometry, connectionMaterial);
            connection.position.x = -stageSpacing * 2 + i * stageSpacing + stageSpacing / 2;
            connection.rotation.z = Math.PI / 2;
            group.add(connection);
        }
    }
    
    // Add animation update function
    group.update = function(time, delta) {
        // Move the model through the pipeline
        model.position.x = -stageSpacing * 3 + ((time * 0.5) % (stageSpacing * 6));
        
        // Reset position after completing the pipeline
        if (model.position.x > stageSpacing * 3) {
            model.position.x = -stageSpacing * 3;
        }
        
        // Rotate model as it moves
        model.rotation.x += delta * 2;
        model.rotation.y += delta * 3;
    };
    
    return group;
}

/**
 * Creates the lighting demo object
 */
function createLightingDemo(position, color) {
    // Create a group to hold all lighting demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create a demo object to showcase lighting
    const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    const sphereMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.5,
        metalness: 0.2
    });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    group.add(sphere);
    
    // Create a point light for the demo
    const pointLight = new THREE.PointLight(0xFFFFFF, 1, 10);
    pointLight.position.set(2, 2, 2);
    group.add(pointLight);
    
    // Create a visual representation of the light
    const lightSphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const lightSphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF
    });
    const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
    lightSphere.position.copy(pointLight.position);
    group.add(lightSphere);
    
    // Add control panel
    const controlPanel = document.createElement('div');
    controlPanel.id = 'lighting-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Lighting Controls</h3>
        <div class="control-group">
            <h4>Light Color</h4>
            <div class="button-group">
                <button data-color="#FFFFFF" class="color-button" style="background-color: #FFFFFF;">Sunshine</button>
                <button data-color="#FF9800" class="color-button" style="background-color: #FF9800;">Orange Glow</button>
                <button data-color="#2196F3" class="color-button" style="background-color: #2196F3;">Blueberry</button>
                <button data-color="#E91E63" class="color-button" style="background-color: #E91E63;">Pink</button>
                <button data-color="#4CAF50" class="color-button" style="background-color: #4CAF50;">Mint</button>
            </div>
        </div>
        <div class="control-group">
            <h4>Light Brightness</h4>
            <input type="range" min="0" max="2" step="0.1" value="1" id="brightness-slider">
        </div>
        <div class="control-group">
            <h4>Material Properties</h4>
            <div class="slider-group">
                <label>Shininess</label>
                <input type="range" min="0" max="1" step="0.1" value="0.5" id="shininess-slider">
            </div>
            <div class="slider-group">
                <label>Metalness</label>
                <input type="range" min="0" max="1" step="0.1" value="0.2" id="metalness-slider">
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add event listeners for the controls
    if (document.getElementById('lighting-controls')) {
        // Color buttons
        const colorButtons = document.querySelectorAll('#lighting-controls .color-button');
        colorButtons.forEach(button => {
            button.addEventListener('click', function() {
                const colorValue = this.getAttribute('data-color');
                pointLight.color.set(colorValue);
                lightSphere.material.color.set(colorValue);
            });
        });
        
        // Brightness slider
        const brightnessSlider = document.getElementById('brightness-slider');
        brightnessSlider.addEventListener('input', function() {
            pointLight.intensity = parseFloat(this.value);
        });
        
        // Material property sliders
        const shininessSlider = document.getElementById('shininess-slider');
        shininessSlider.addEventListener('input', function() {
            const roughness = 1 - parseFloat(this.value);
            sphereMaterial.roughness = roughness;
            sphereMaterial.needsUpdate = true;
        });
        
        const metalnessSlider = document.getElementById('metalness-slider');
        metalnessSlider.addEventListener('input', function() {
            sphereMaterial.metalness = parseFloat(this.value);
            sphereMaterial.needsUpdate = true;
        });
    }
    
    // Store controls reference for show/hide
    stationControls.lighting = {
        show: function() {
            const controls = document.getElementById('lighting-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('lighting-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Rotate light around sphere
        const angle = time * 0.5;
        const radius = 2;
        const height = Math.sin(time * 0.3) + 2;
        
        pointLight.position.x = Math.cos(angle) * radius;
        pointLight.position.y = height;
        pointLight.position.z = Math.sin(angle) * radius;
        
        lightSphere.position.copy(pointLight.position);
    };
    
    return group;
}

/**
 * Creates the texturing demo object
 */
function createTexturingDemo(position, color) {
    // Create a group to hold all texturing demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create a cube to showcase texturing
    const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
    const cubeMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.7,
        metalness: 0.2
    });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    group.add(cube);
    
    // Setup texture parameters
    let currentTexture = 'bricks';
    let textureRepeat = 1;
    let textureRotation = 0;
    
    // Generate procedural textures
    const textureSize = 512;
    const generateProceduralTexture = (type) => {
        const canvas = document.createElement('canvas');
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext('2d');
        
        // Clear canvas with white
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, textureSize, textureSize);
        
        switch (type) {
            case 'bricks':
                // Draw brick pattern
                const brickWidth = 60;
                const brickHeight = 30;
                const mortarSize = 5;
                
                ctx.fillStyle = '#A52A2A';
                
                for (let y = 0; y < textureSize; y += brickHeight + mortarSize) {
                    // Alternate brick rows
                    const offset = (Math.floor(y / (brickHeight + mortarSize)) % 2) * (brickWidth / 2);
                    
                    for (let x = -offset; x < textureSize; x += brickWidth + mortarSize) {
                        ctx.fillRect(x, y, brickWidth, brickHeight);
                    }
                }
                break;
                
            case 'wood':
                // Draw wood grain pattern
                const baseColor = '#8B4513';
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, textureSize, textureSize);
                
                // Add wood grain
                ctx.strokeStyle = '#603311';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * textureSize;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    
                    // Create wavy line
                    for (let y = 0; y < textureSize; y += 10) {
                        const xOffset = x + Math.sin(y * 0.05) * 5 + Math.random() * 3;
                        ctx.lineTo(xOffset, y);
                    }
                    
                    ctx.stroke();
                }
                break;
                
            case 'stone':
                // Draw stone pattern
                ctx.fillStyle = '#888888';
                ctx.fillRect(0, 0, textureSize, textureSize);
                
                // Add stone pattern
                for (let i = 0; i < 50; i++) {
                    const size = 20 + Math.random() * 40;
                    const x = Math.random() * textureSize;
                    const y = Math.random() * textureSize;
                    const shade = 100 + Math.floor(Math.random() * 100);
                    
                    ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add cracks
                ctx.strokeStyle = '#555555';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * textureSize;
                    const y = Math.random() * textureSize;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    
                    // Create random crack
                    let currentX = x;
                    let currentY = y;
                    const segments = 5 + Math.floor(Math.random() * 5);
                    
                    for (let j = 0; j < segments; j++) {
                        currentX += (Math.random() - 0.5) * 40;
                        currentY += (Math.random() - 0.5) * 40;
                        ctx.lineTo(currentX, currentY);
                    }
                    
                    ctx.stroke();
                }
                break;
                
            case 'checkerboard':
                // Draw checkerboard pattern
                const squareSize = 64;
                
                for (let y = 0; y < textureSize; y += squareSize) {
                    for (let x = 0; x < textureSize; x += squareSize) {
                        const isEven = (Math.floor(x / squareSize) + Math.floor(y / squareSize)) % 2 === 0;
                        ctx.fillStyle = isEven ? '#000000' : '#FFFFFF';
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }
                break;
                
            case 'dots':
                // Draw dot pattern
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, textureSize, textureSize);
                
                const dotSize = 10;
                const spacing = 40;
                
                ctx.fillStyle = '#000000';
                
                for (let y = spacing / 2; y < textureSize; y += spacing) {
                    for (let x = spacing / 2; x < textureSize; x += spacing) {
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                break;
                
            default:
                // Default pattern
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, textureSize, textureSize);
        }
        
        return new THREE.CanvasTexture(canvas);
    };
    
    // Apply texture to the cube
    const applyTexture = (textureType) => {
        currentTexture = textureType;
        
        const texture = generateProceduralTexture(textureType);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(textureRepeat, textureRepeat);
        texture.rotation = textureRotation;
        
        cubeMaterial.map = texture;
        cubeMaterial.needsUpdate = true;
    };
    
    // Initially apply brick texture
    applyTexture('bricks');
    
    // Add texture control panel
    const controlPanel = document.createElement('div');
    controlPanel.id = 'texturing-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Texture Controls</h3>
        <div class="control-group">
            <h4>Texture Type</h4>
            <div class="button-group">
                <button data-texture="bricks" class="texture-button">Bricks</button>
                <button data-texture="wood" class="texture-button">Wood</button>
                <button data-texture="stone" class="texture-button">Stone</button>
                <button data-texture="checkerboard" class="texture-button">Checkers</button>
                <button data-texture="dots" class="texture-button">Dots</button>
            </div>
        </div>
        <div class="control-group">
            <h4>Texture Repeat</h4>
            <input type="range" min="0.5" max="5" step="0.5" value="1" id="repeat-slider">
        </div>
        <div class="control-group">
            <h4>Texture Rotation</h4>
            <div class="button-group">
                <button id="rotate-left">⟲ Rotate Left</button>
                <button id="rotate-right">⟳ Rotate Right</button>
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add event listeners for the controls
    if (document.getElementById('texturing-controls')) {
        // Texture type buttons
        const textureButtons = document.querySelectorAll('#texturing-controls .texture-button');
        textureButtons.forEach(button => {
            button.addEventListener('click', function() {
                const textureType = this.getAttribute('data-texture');
                applyTexture(textureType);
            });
        });
        
        // Repeat slider
        const repeatSlider = document.getElementById('repeat-slider');
        repeatSlider.addEventListener('input', function() {
            textureRepeat = parseFloat(this.value);
            if (cubeMaterial.map) {
                cubeMaterial.map.repeat.set(textureRepeat, textureRepeat);
                cubeMaterial.needsUpdate = true;
            }
        });
        
        // Rotation buttons
        const rotateLeftButton = document.getElementById('rotate-left');
        rotateLeftButton.addEventListener('click', function() {
            textureRotation -= Math.PI / 6;
            if (cubeMaterial.map) {
                cubeMaterial.map.rotation = textureRotation;
                cubeMaterial.needsUpdate = true;
            }
        });
        
        const rotateRightButton = document.getElementById('rotate-right');
        rotateRightButton.addEventListener('click', function() {
            textureRotation += Math.PI / 6;
            if (cubeMaterial.map) {
                cubeMaterial.map.rotation = textureRotation;
                cubeMaterial.needsUpdate = true;
            }
        });
    }
    
    // Store controls reference for show/hide
    stationControls.texturing = {
        show: function() {
            const controls = document.getElementById('texturing-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('texturing-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Rotate cube slowly
        cube.rotation.y += delta * 0.2;
    };
    
    return group;
}

/**
 * Creates the geometry demo object
 */
function createGeometryDemo(position, color) {
    // Create a group to hold all geometry demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create an array of different geometries
    const geometries = [
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.SphereGeometry(0.7, 16, 16),
        new THREE.ConeGeometry(0.7, 1.5, 16),
        new THREE.TorusGeometry(0.7, 0.3, 16, 32),
        new THREE.TetrahedronGeometry(0.8),
        new THREE.OctahedronGeometry(0.8)
    ];
    
    // Create materials for the geometries
    const materials = [
        new THREE.MeshStandardMaterial({ color: 0x4CAF50, roughness: 0.5 }),
        new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.5 }),
        new THREE.MeshStandardMaterial({ color: 0xFF9800, roughness: 0.5 }),
        new THREE.MeshStandardMaterial({ color: 0x9C27B0, roughness: 0.5 }),
        new THREE.MeshStandardMaterial({ color: 0xF44336, roughness: 0.5 }),
        new THREE.MeshStandardMaterial({ color: 0xFFEB3B, roughness: 0.5 })
    ];
    
    // Create meshes for each geometry and position them in a circle
    const meshes = [];
    const radius = 2;
    
    for (let i = 0; i < geometries.length; i++) {
        const angle = (i / geometries.length) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const mesh = new THREE.Mesh(geometries[i], materials[i]);
        mesh.position.set(x, 0, z);
        
        group.add(mesh);
        meshes.push(mesh);
    }
    
    // Add a light to illuminate the geometries
    const light = new THREE.PointLight(0xFFFFFF, 1, 10);
    light.position.set(0, 2, 0);
    group.add(light);
    
    // Add animation update function
    group.update = function(time, delta) {
        // Rotate each geometry differently
        for (let i = 0; i < meshes.length; i++) {
            meshes[i].rotation.x += delta * (0.5 + i * 0.1);
            meshes[i].rotation.y += delta * (0.3 + i * 0.1);
            
            // Make geometries bob up and down
            const bobHeight = Math.sin(time * (0.5 + i * 0.1)) * 0.2;
            meshes[i].position.y = bobHeight;
        }
        
        // Rotate the entire group slowly
        group.rotation.y += delta * 0.1;
    };
    
    return group;
}

/**
 * Creates the shader demo object
 */
function createShaderDemo(position, color) {
    // Create a group to hold all shader demo objects
    const group = new THREE.Group();
    group.position.copy(position);
    group.position.y += 3; // Raise above platform
    
    // Create custom shader material
    const vertexShader = `
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;
    
    const fragmentShader = `
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float waveFrequency;
        uniform float waveAmplitude;
        uniform float blendFactor;
        
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
            // Create a wave pattern
            float wave = sin(vUv.x * waveFrequency + time) * sin(vUv.y * waveFrequency + time) * waveAmplitude;
            
            // Mix colors based on wave pattern
            vec3 mixedColor = mix(color1, color2, wave * blendFactor + 0.5);
            
            gl_FragColor = vec4(mixedColor, 1.0);
        }
    `;
    
    // Initial shader parameters
    const shaderUniforms = {
        time: { value: 0 },
        color1: { value: new THREE.Color(0x2196F3) },
        color2: { value: new THREE.Color(0xFF9800) },
        waveFrequency: { value: 10.0 },
        waveAmplitude: { value: 0.5 },
        blendFactor: { value: 0.8 }
    };
    
    const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: shaderUniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.DoubleSide
    });
    
    // Create a plane to display the shader
    const planeGeometry = new THREE.PlaneGeometry(2, 2, 32, 32);
    const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
    group.add(plane);
    
    // Add shader control panel
    const controlPanel = document.createElement('div');
    controlPanel.id = 'shader-controls';
    controlPanel.className = 'station-controls';
    controlPanel.style.display = 'none';
    controlPanel.innerHTML = `
        <h3>Shader Controls</h3>
        <div class="control-group">
            <h4>Colors</h4>
            <div class="color-control">
                <label>Color 1</label>
                <div class="button-group">
                    <button data-color="#2196F3" class="color-button" style="background-color: #2196F3;"></button>
                    <button data-color="#F44336" class="color-button" style="background-color: #F44336;"></button>
                    <button data-color="#4CAF50" class="color-button" style="background-color: #4CAF50;"></button>
                </div>
            </div>
            <div class="color-control">
                <label>Color 2</label>
                <div class="button-group">
                    <button data-color="#FF9800" class="color-button" style="background-color: #FF9800;"></button>
                    <button data-color="#9C27B0" class="color-button" style="background-color: #9C27B0;"></button>
                    <button data-color="#FFEB3B" class="color-button" style="background-color: #FFEB3B;"></button>
                </div>
            </div>
        </div>
        <div class="control-group">
            <h4>Wave Pattern</h4>
            <div class="slider-group">
                <label>Frequency</label>
                <input type="range" min="1" max="30" step="1" value="10" id="frequency-slider">
            </div>
            <div class="slider-group">
                <label>Amplitude</label>
                <input type="range" min="0" max="1" step="0.1" value="0.5" id="amplitude-slider">
            </div>
        </div>
        <div class="control-group">
            <h4>Blend Settings</h4>
            <div class="slider-group">
                <label>Blend Factor</label>
                <input type="range" min="0" max="1" step="0.1" value="0.8" id="blend-slider">
            </div>
        </div>
    `;
    document.body.appendChild(controlPanel);
    
    // Add event listeners for the controls
    if (document.getElementById('shader-controls')) {
        // Color buttons for color 1
        const color1Buttons = document.querySelectorAll('#shader-controls .color-control:nth-child(1) .color-button');
        color1Buttons.forEach(button => {
            button.addEventListener('click', function() {
                const colorValue = this.getAttribute('data-color');
                shaderUniforms.color1.value.set(colorValue);
            });
        });
        
        // Color buttons for color 2
        const color2Buttons = document.querySelectorAll('#shader-controls .color-control:nth-child(2) .color-button');
        color2Buttons.forEach(button => {
            button.addEventListener('click', function() {
                const colorValue = this.getAttribute('data-color');
                shaderUniforms.color2.value.set(colorValue);
            });
        });
        
        // Frequency slider
        const frequencySlider = document.getElementById('frequency-slider');
        frequencySlider.addEventListener('input', function() {
            shaderUniforms.waveFrequency.value = parseFloat(this.value);
        });
        
        // Amplitude slider
        const amplitudeSlider = document.getElementById('amplitude-slider');
        amplitudeSlider.addEventListener('input', function() {
            shaderUniforms.waveAmplitude.value = parseFloat(this.value);
        });
        
        // Blend factor slider
        const blendSlider = document.getElementById('blend-slider');
        blendSlider.addEventListener('input', function() {
            shaderUniforms.blendFactor.value = parseFloat(this.value);
        });
    }
    
    // Store controls reference for show/hide
    stationControls.shaders = {
        show: function() {
            const controls = document.getElementById('shader-controls');
            if (controls) controls.style.display = 'block';
        },
        hide: function() {
            const controls = document.getElementById('shader-controls');
            if (controls) controls.style.display = 'none';
        }
    };
    
    // Add animation update function
    group.update = function(time, delta) {
        // Update shader time uniform
        shaderUniforms.time.value = time;
        
        // Rotate plane slowly
        plane.rotation.y += delta * 0.2;
    };
    
    return group;
}

/**
 * Adds decorative elements to the world
 */
function addWorldDecorations() {
    // Add trees around the world
    addTrees();
    
    // Add particle effects
    addParticles();
}

/**
 * Adds trees throughout the world for decoration
 */
function addTrees() {
    // Create trees at various positions
    for (let i = 0; i < 20; i++) {
        const x = (Math.random() - 0.5) * 80;
        const z = (Math.random() - 0.5) * 80;
        
        // Don't place trees too close to stations
        let tooClose = false;
        for (const stationKey in learningStations) {
            const station = learningStations[stationKey];
            const dx = station.position.x - x;
            const dz = station.position.z - z;
            const distSquared = dx*dx + dz*dz;
            
            if (distSquared < 100) { // 10 units radius
                tooClose = true;
                break;
            }
        }
        
        if (!tooClose) {
            createTree(x, z);
        }
    }
}

/**
 * Creates a tree at the specified position
 */
function createTree(x, z) {
    // Create trunk
    const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({
        color: 0x8B4513,
        roughness: 0.9
    });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(x, 1, z);
    trunk.castShadow = true;
    scene.add(trunk);
    
    // Create foliage (leaves)
    const foliageGeometry = new THREE.ConeGeometry(2, 5, 8);
    const foliageMaterial = new THREE.MeshStandardMaterial({
        color: 0x2E8B57,
        roughness: 0.8
    });
    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
    foliage.position.set(x, 4, z);
    foliage.castShadow = true;
    scene.add(foliage);
}

/**
 * Adds particle effects to the world
 */
function addParticles() {
    // Create particles for atmospheric effect
    const particleCount = 1000;
    const particles = new THREE.BufferGeometry();
    
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        // Position particles randomly within a large cube
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 20;  // Height up to 20 units
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        // Give particles a slight blue-white color
        colors[i * 3] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 2] = 0.9 + Math.random() * 0.1;
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 0.5
    });
    
    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);
}

/**
 * Creates a world border to prevent players from leaving the area
 */
function createWorldBorder() {
    const wallHeight = 10;
    const worldSize = 50;
    const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x888888,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    // Create four walls
    const walls = [
        // North wall
        { pos: [0, wallHeight/2 - 1, -worldSize], size: [worldSize*2, wallHeight, 0.5] },
        // South wall
        { pos: [0, wallHeight/2 - 1, worldSize], size: [worldSize*2, wallHeight, 0.5] },
        // East wall
        { pos: [worldSize, wallHeight/2 - 1, 0], size: [0.5, wallHeight, worldSize*2] },
        // West wall
        { pos: [-worldSize, wallHeight/2 - 1, 0], size: [0.5, wallHeight, worldSize*2] }
    ];
    
    walls.forEach(wall => {
        const geometry = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
        const mesh = new THREE.Mesh(geometry, wallMaterial);
        mesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
        mesh.receiveShadow = true;
        scene.add(mesh);
    });
}

// Ensure functions are properly exposed to the global scope
console.log('World.js loaded, checking function availability');
if (typeof createWorld !== 'function') {
    console.error('createWorld function is not properly defined in the global scope');
    // Try to explicitly expose it
    window.createWorld = createWorld;
    window.createSkybox = createSkybox;
    window.createTerrain = createTerrain;
    window.checkStationProximity = checkStationProximity;
    window.updateWorld = updateWorld;
    console.log('Functions explicitly exposed to window object');
} else {
    console.log('createWorld function is properly defined in the global scope');
}

//=============================================================================
// EXPORTS
//=============================================================================

// Export public functions and variables
export {
    initWorld,
    updateWorld,
    checkStationProximity,
    learningStations,
    terrain
}; 