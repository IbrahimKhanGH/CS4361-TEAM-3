/**
 * 3D World environment for the Graphics Learning Studio
 * This file handles the creation and management of the 3D world that users navigate through
 */

// World objects and settings
let terrain, skybox;
let learningStations = {};
let currentStation = null;

// Textures
let textures = {};

// Descriptions for learning stations
const stationDescriptions = {
    pipeline: "The graphics pipeline is the sequence of steps used to create a 2D representation of a 3D scene. Major stages include vertex processing, primitive assembly, rasterization, and fragment processing.",
    lighting: "Lighting models simulate how light interacts with surfaces. Key concepts include ambient light, diffuse reflection, and specular reflection, as well as shadows and global illumination techniques.\n\nAmbient lighting simulates indirect light scattered throughout a scene, ensuring objects are never completely dark. It represents the effect of light bouncing off multiple surfaces, so even areas not directly lit by a light source remain visible.\n\nDiffuse reflection occurs when light hits a rough surface and is scattered equally in all directions. This gives objects their basic color and soft shading, and is characteristic of matte or non-shiny surfaces, often called Lambertian reflectors.\n\nSpecular reflection happens when light reflects off a smooth surface in a specific direction, creating a bright, concentrated highlight. The size and sharpness of this highlight depend on how smooth or shiny the material is-glossy surfaces produce small, sharp highlights, while duller surfaces create larger, softer ones.",
    texturing: "Texturing is a fundamental technique in computer graphics used to add detail, and realism to the surfaces of 2D and 3D objects. Instead of modeling each tiny feature geometrically, textures let programmers paint detailed images and patterns onto surfaces without increasing computational cost. Some important techniques used are Texture Mapping, and Procedural Texturing.\n\nTexture Mapping is the process of applying a 2D image to a 3D surface. Each vertex of a polygon is assigned a texture coordinate, and is the most common texturing technique.\n\nProcedural Texturing is when textures are generated by mathmatical functions. Generating textures this way allows for dynamic, scalable and memory efficient surface patterns. It's useful when you need textures at arbitrary resolutions",
    geometry: "Geometry in computer graphics involves creating and manipulating 3D shapes. This includes mesh representation, subdivision surfaces, and procedural geometry generation.",
    shaders: "Shaders are programs that run on the GPU to determine how objects are rendered. They control vertex positions, lighting calculations, and pixel colors."
};

/**
 * Creates the 3D world environment
 */
function createWorld() {
    // Create skybox
    createSkybox();
    
    // Create terrain
    createTerrain();
    
    // Create learning stations
    createLearningStations();
    
    // Add decorative elements
    addWorldDecorations();

    // Add world border walls
    createWorldBorder();
}

/**
 * Creates a skybox for the 3D world
 */
function createSkybox() {
    try {
        const loader = new THREE.CubeTextureLoader();
        loader.setPath('assets/textures/skybox/');
        
        // Placeholder for actual skybox textures
        // In a real implementation, you would have these files
        const skyboxTexture = loader.load([
            'px.jpg', 'nx.jpg',
            'py.jpg', 'ny.jpg',
            'pz.jpg', 'nz.jpg'
        ], 
        // Success callback
        undefined, 
        // Error callback
        function(err) {
            console.log('Error loading skybox textures, using fallback color');
            scene.background = new THREE.Color(0x88ccee);
        });
        
        scene.background = skyboxTexture;
    } catch (error) {
        console.log('Error creating skybox, using fallback color');
        scene.background = new THREE.Color(0x88ccee);
    }
}

/**
 * Creates the terrain for the 3D world
 */
function createTerrain() {
    console.log('Creating terrain');
    
    // Create a large ground plane
    const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
    
    // Default ground material (fallback)
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x567d46,
        roughness: 0.8,
        metalness: 0.2
    });
    
    // Try to load ground texture
    try {
        const textureLoader = new THREE.TextureLoader();
        textureLoader.setPath('assets/textures/');
        
        // Placeholder for actual ground textures
        // In a real implementation, you would have these files
        textureLoader.load('ground.jpg', 
            // Success callback
            function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
                groundMaterial.map = texture;
                groundMaterial.needsUpdate = true;
                console.log('Ground texture loaded successfully');
            },
            // Progress callback
            undefined,
            // Error callback
            function(err) {
                console.log('Error loading ground texture, using fallback color');
            }
        );
    } catch (error) {
        console.log('Error loading texture, using fallback color');
    }
    
    terrain = new THREE.Mesh(groundGeometry, groundMaterial);
    terrain.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    terrain.position.y = -1; // Raised position by 1 unit
    terrain.receiveShadow = true;
    scene.add(terrain);
    
    console.log('Terrain created at position:', terrain.position);
    
    // Add some terrain features like hills
    addTerrainFeatures();
}

/**
 * Adds features to the terrain like hills and valleys
 */
function addTerrainFeatures() {
    // Add some hills using simple geometries
    const hillGeometry = new THREE.ConeGeometry(10, 5, 16);
    const hillMaterial = new THREE.MeshStandardMaterial({
        color: 0x567d46,
        roughness: 0.9
    });
    
    // Create a few hills at different positions
    const hill1 = new THREE.Mesh(hillGeometry, hillMaterial);
    hill1.position.set(-30, -2, -20);
    hill1.scale.set(1, 0.5, 1);
    scene.add(hill1);
    
    const hill2 = new THREE.Mesh(hillGeometry, hillMaterial);
    hill2.position.set(25, -2, -15);
    hill2.scale.set(0.8, 0.6, 0.8);
    scene.add(hill2);
}

/**
 * Creates interactive learning stations throughout the 3D world
 */
function createLearningStations() {
    // Create the Pipeline Station
    learningStations.pipeline = createStation(
        'Pipeline', 
        new THREE.Vector3(-15, 0, -15),
        0x4CAF50
    );
    
    // Create the Lighting Station
    learningStations.lighting = createStation(
        'Lighting', 
        new THREE.Vector3(15, 0, -15),
        0xFFC107
    );
    
    // Create the Texturing Station
    learningStations.texturing = createStation(
        'Texturing', 
        new THREE.Vector3(-15, 0, 15),
        0x2196F3
    );
    
    // Create the Geometry Station
    learningStations.geometry = createStation(
        'Geometry', 
        new THREE.Vector3(15, 0, 15),
        0xE91E63
    );
    
    // Create the Shader Station
    learningStations.shaders = createStation(
        'Shaders', 
        new THREE.Vector3(0, 0, -25),
        0x9C27B0
    );
}

/**
 * Creates a single learning station with interactive elements
 * @param {string} name - The name of the station
 * @param {THREE.Vector3} position - The position in the 3D world
 * @param {number} color - The color of the station
 * @returns {Object} - The station object
 */
function createStation(name, position, color) {
    // Create a platform for the station
    const platformGeometry = new THREE.CylinderGeometry(5, 5, 0.5, 32);
    const platformMaterial = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.3,
        roughness: 0.5
    });
    
    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
    platform.position.copy(position);
    platform.position.y = -0.25; // Half height of platform
    platform.receiveShadow = true;
    scene.add(platform);
    
    // Create a holographic display
    const displayGeometry = new THREE.BoxGeometry(3, 4, 0.1);
    const displayMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: color,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.7
    });
    
    const display = new THREE.Mesh(displayGeometry, displayMaterial);
    display.position.copy(position);
    display.position.y = 2; // Height of display
    display.castShadow = false; // Explicitly set to false
    scene.add(display);
    
    // Create a floating name label
    const textMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff
    });
    
    // In a real implementation, you would use a TextGeometry
    // For now, we'll use a simple placeholder
    const labelGeometry = new THREE.PlaneGeometry(4, 0.8);
    const label = new THREE.Mesh(labelGeometry, textMaterial);
    label.position.copy(position);
    label.position.y = 4.5;
    scene.add(label);
    
    // Create a demo object specific to this station
    const demoObject = createStationDemoObject(name, position, color);
    
    // Return the station object with all its components
    return {
        name: name,
        position: position,
        platform: platform,
        display: display,
        label: label,
        demoObject: demoObject,
        
        // Method to activate this station
        activate: function() {
            // Highlight the platform
            platform.material.emissive = new THREE.Color(color);
            platform.material.emissiveIntensity = 0.5;
            
            // Get the description for this station
            const stationKey = name.toLowerCase();
            const description = stationDescriptions[stationKey] || 'Explore this station to learn about ' + name + '.';
            
            // Update UI with station info
            updateStationInfo(name, description);
            
            // Animate the demo object
            this.demoObject.visible = true;
            // If the demo object has an init method (e.g., for resetting animation), call it
            if (this.demoObject.init) {
                this.demoObject.init();
            }
            
            // Set up interactive controls if the demo supports it
            if (this.demoObject.setupControls) {
                this.demoObject.setupControls();
            }
            
            // Set as current station
            currentStation = this;
        },
        
        // Method to deactivate this station
        deactivate: function() {
            // Remove highlight
            platform.material.emissiveIntensity = 0;
            
            // Hide demo object
            this.demoObject.visible = false;
            
            // Remove interactive controls if the demo supports it
            if (this.demoObject.removeControls) {
                this.demoObject.removeControls();
            }
        }
    };
}

/**
 * Creates a demo object specific to each learning station
 * @param {string} stationType - The type of station
 * @param {THREE.Vector3} position - The position in the 3D world
 * @param {number} color - The color of the demo object
 * @returns {THREE.Object3D} - The demo object
 */
function createStationDemoObject(stationType, position, color) {
    let demoObject;
    
    switch(stationType.toLowerCase()) {
        case 'pipeline':
            // Create a pipeline visualization
            demoObject = createPipelineDemo(position, color);
            break;
            
        case 'lighting':
            // Create a lighting demonstration
            demoObject = createLightingDemo(position, color);
            break;
            
        case 'texturing':
            // Create a texturing demonstration
            demoObject = createTexturingDemo(position, color);
            break;
            
        case 'geometry':
            // Create a geometry demonstration
            demoObject = createGeometryDemo(position, color);
            break;
            
        case 'shaders':
            // Create a shader demonstration
            demoObject = createShaderDemo(position, color);
            break;
            
        default:
            // Default demo object is a spinning cube
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.7,
                roughness: 0.3
            });
            demoObject = new THREE.Mesh(geometry, material);
    }
    
    // Position the demo object above the platform
    demoObject.position.copy(position);
    demoObject.position.y = 2;
    demoObject.visible = false; // Initially hidden
    scene.add(demoObject);
    
    return demoObject;
}

/**
 * Creates a pipeline visualization demo
 */
function createPipelineDemo(position, color) {
    // Create a group to hold all pipeline elements
    const pipelineGroup = new THREE.Group();
    pipelineGroup.position.copy(position);
    pipelineGroup.position.y = 1.5;
    
    // Pipeline stages parameters
    const stageCount = 5;
    const stageSpacing = 1.2;
    const startX = -(stageCount - 1) / 2 * stageSpacing;
    const endX = (stageCount - 1) / 2 * stageSpacing;
    
    // Create pipeline stages as connected boxes
    const stageGeometry = new THREE.BoxGeometry(1, 0.5, 0.5);
    const stageMaterial = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.5,
        roughness: 0.5
    });
    
    for (let i = 0; i < stageCount; i++) {
        const stage = new THREE.Mesh(stageGeometry, stageMaterial.clone());
        stage.position.x = (i - (stageCount - 1) / 2) * stageSpacing;
        pipelineGroup.add(stage);
        
        // Add connecting "pipes" between stages
        if (i < stageCount - 1) {
            const pipeGeometry = new THREE.CylinderGeometry(0.1, 0.1, stageSpacing - 0.2, 8);
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            pipe.rotation.z = Math.PI / 2;
            pipe.position.x = (i - (stageCount - 1) / 2) * stageSpacing + stageSpacing / 2;
            pipelineGroup.add(pipe);
        }
    }

    // Create a "packet" to animate through the pipeline
    const packetGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const packetMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const packet = new THREE.Mesh(packetGeometry, packetMaterial);
    packet.position.set(startX, 0, 0); // Start at the beginning
    pipelineGroup.add(packet);

    // Store necessary variables for animation
    pipelineGroup.packet = packet;
    pipelineGroup.startX = startX;
    pipelineGroup.endX = endX;
    pipelineGroup.animationProgress = 0;
    pipelineGroup.animationDuration = 5; // seconds to travel pipeline

    // Add an init function to reset the animation
    pipelineGroup.init = function() {
        this.packet.position.x = this.startX;
        this.animationProgress = 0;
    };

    // Add animation function to the group
    pipelineGroup.update = function(time, delta) { // Pass delta time
        if (!this.visible) return; // Don't update if not visible

        this.animationProgress += delta;
        if (this.animationProgress > this.animationDuration) {
            this.animationProgress = 0; // Loop animation
        }

        const progressRatio = this.animationProgress / this.animationDuration;
        this.packet.position.x = this.startX + (this.endX - this.startX) * progressRatio;
    };
    
    return pipelineGroup;
}

/**
 * Creates a lighting demonstration
 */
function createLightingDemo(position, color) {
    // Create a group for the lighting demo
    const lightingGroup = new THREE.Group();
    lightingGroup.position.copy(position);
    lightingGroup.position.y = 1.5;
    
    // Create a sphere to demonstrate lighting
    const sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
    const sphereMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.2
    });
    
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    lightingGroup.add(sphere);
    
    // Add a point light that orbits the sphere
    const demoLight = new THREE.PointLight(color, 1, 10);
    demoLight.position.set(1.5, 0, 0);
    lightingGroup.add(demoLight);
    
    // Add a small sphere to represent the light
    const lightSphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const lightSphereMaterial = new THREE.MeshBasicMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 1
    });
    
    const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
    lightSphere.position.copy(demoLight.position);
    lightingGroup.add(lightSphere);
    
    // Create interactive controls - store elements so they can be shown/hidden
    lightingGroup.controlsElements = [];
    
    // Setup controls for when station is activated
    lightingGroup.setupControls = function() {
        // Remove any existing controls first
        this.removeControls();
        
        // Create controls container
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'station-controls lighting-controls';
        controlsContainer.style.position = 'absolute';
        controlsContainer.style.bottom = '20px';
        controlsContainer.style.left = '50%';
        controlsContainer.style.transform = 'translateX(-50%)';
        controlsContainer.style.padding = '10px';
        controlsContainer.style.backgroundColor = 'rgba(0,0,0,0.5)';
        controlsContainer.style.borderRadius = '10px';
        controlsContainer.style.color = 'white';
        controlsContainer.style.fontFamily = 'Arial, sans-serif';
        controlsContainer.style.textAlign = 'center';
        controlsContainer.style.zIndex = '1000';
        document.body.appendChild(controlsContainer);
        this.controlsElements.push(controlsContainer);
        
        // Add title
        const title = document.createElement('h3');
        title.textContent = 'Light Magic!';
        title.style.margin = '0 0 10px 0';
        title.style.fontSize = '18px';
        controlsContainer.appendChild(title);
        
        // Color control section
        const colorSection = document.createElement('div');
        colorSection.style.marginBottom = '15px';
        controlsContainer.appendChild(colorSection);
        
        // Color buttons with kid-friendly names
        const colorTitle = document.createElement('div');
        colorTitle.textContent = 'Choose a Light Color:';
        colorTitle.style.marginBottom = '5px';
        colorSection.appendChild(colorTitle);
        
        const colorButtons = document.createElement('div');
        colorButtons.style.display = 'flex';
        colorButtons.style.justifyContent = 'center';
        colorButtons.style.gap = '10px';
        colorSection.appendChild(colorButtons);
        
        // Define kid-friendly colors
        const lightColors = [
            { name: 'Sunshine', value: '#FFF176' },
            { name: 'Blueberry', value: '#42A5F5' },
            { name: 'Watermelon', value: '#EF5350' },
            { name: 'Lime', value: '#66BB6A' },
            { name: 'Grape', value: '#AB47BC' }
        ];
        
        lightColors.forEach(colorInfo => {
            const colorBtn = document.createElement('button');
            colorBtn.style.width = '20px';
            colorBtn.style.height = '20px';
            colorBtn.style.backgroundColor = colorInfo.value;
            colorBtn.style.border = 'none';
            colorBtn.style.borderRadius = '50%';
            colorBtn.style.cursor = 'pointer';
            colorBtn.title = colorInfo.name;
            
            colorBtn.addEventListener('click', () => {
                const newColor = new THREE.Color(colorInfo.value);
                demoLight.color.set(newColor);
                lightSphereMaterial.color.set(newColor);
                lightSphereMaterial.emissive.set(newColor);
            });
            
            colorButtons.appendChild(colorBtn);
        });
        
        // Light intensity slider
        const intensitySection = document.createElement('div');
        intensitySection.style.marginBottom = '15px';
        controlsContainer.appendChild(intensitySection);
        
        const intensityTitle = document.createElement('div');
        intensityTitle.textContent = 'Light Brightness:';
        intensityTitle.style.marginBottom = '5px';
        intensitySection.appendChild(intensityTitle);
        
        const intensitySlider = document.createElement('input');
        intensitySlider.type = 'range';
        intensitySlider.min = '0';
        intensitySlider.max = '2';
        intensitySlider.step = '0.1';
        intensitySlider.value = '1';
        intensitySlider.style.width = '100%';
        intensitySlider.style.accentColor = '#FFC107';
        intensitySection.appendChild(intensitySlider);
        
        intensitySlider.addEventListener('input', () => {
            demoLight.intensity = parseFloat(intensitySlider.value);
        });
        
        // Material shininess slider
        const shininessSection = document.createElement('div');
        controlsContainer.appendChild(shininessSection);
        
        const shininessTitle = document.createElement('div');
        shininessTitle.textContent = 'Object Shininess:';
        shininessTitle.style.marginBottom = '5px';
        shininessSection.appendChild(shininessTitle);
        
        const shininessSlider = document.createElement('input');
        shininessSlider.type = 'range';
        shininessSlider.min = '0';
        shininessSlider.max = '1';
        shininessSlider.step = '0.05';
        shininessSlider.value = sphere.material.roughness;
        shininessSlider.style.width = '100%';
        shininessSlider.style.accentColor = '#FFC107';
        shininessSection.appendChild(shininessSlider);
        
        shininessSlider.addEventListener('input', () => {
            const shininess = 1 - parseFloat(shininessSlider.value);  // Invert for intuitive control
            sphere.material.roughness = parseFloat(shininessSlider.value);
            sphere.material.metalness = shininess * 0.7; // Scale to reasonable metalness
        });
    };
    
    // Method to remove controls
    lightingGroup.removeControls = function() {
        if (this.controlsElements) {
            this.controlsElements.forEach(element => {
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            this.controlsElements = [];
        }
    };
    
    // Add animation function to the group
    lightingGroup.update = function(time) {
        // Orbit the light around the sphere
        demoLight.position.x = Math.sin(time * 2) * 1.5;
        demoLight.position.z = Math.cos(time * 2) * 1.5;
        lightSphere.position.copy(demoLight.position);
    };
    
    return lightingGroup;
}

/**
 * Creates a texturing demonstration
 */
function createTexturingDemo(position, color) {
    // Create a group for the texturing demo
    const texturingGroup = new THREE.Group();
    texturingGroup.position.copy(position);
    texturingGroup.position.y = 1.5;
    
    // Default cube material (fallback)
    const cubeMaterial = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.1,
        roughness: 0.8
    });
    
    // Create textures array to store loaded textures
    const textures = [];
    let currentTextureIndex = 0;
    
    // Create procedural textures - no need to load external files
    const textureSize = 256;
    
    // Define texture types with colors
    const textureTypes = [
        { name: 'Bricks', color: new THREE.Color(0xbb4444) },
        { name: 'Wood', color: new THREE.Color(0x8b4513) },
        { name: 'Stone', color: new THREE.Color(0x888888) },
        { name: 'Grass', color: new THREE.Color(0x44aa44) },
        { name: 'Metal', color: new THREE.Color(0x999999) }
    ];
    
    // Create a procedural texture for each type
    textureTypes.forEach((texInfo, index) => {
        // Create canvas for the texture
        const canvas = document.createElement('canvas');
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext('2d');
        
        // Draw base color
        ctx.fillStyle = `rgb(${Math.floor(texInfo.color.r * 255)}, ${Math.floor(texInfo.color.g * 255)}, ${Math.floor(texInfo.color.b * 255)})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add texture pattern based on type
        switch(texInfo.name) {
            case 'Bricks':
                // Simple brick pattern
                const brickWidth = 40;
                const brickHeight = 20;
                ctx.fillStyle = '#aa3333';
                for (let y = 0; y < canvas.height; y += brickHeight) {
                    const offset = (Math.floor(y / brickHeight) % 2) * (brickWidth / 2);
                    for (let x = 0; x < canvas.width; x += brickWidth) {
                        ctx.fillRect(x + offset, y, brickWidth - 4, brickHeight - 4);
                    }
                }
                break;
                
            case 'Wood':
                // Wood grain
                for (let i = 0; i < 20; i++) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, Math.random() * canvas.height);
                    ctx.lineTo(canvas.width, Math.random() * canvas.height);
                    ctx.stroke();
                }
                break;
                
            case 'Stone':
                // Stone texture
                for (let i = 0; i < 50; i++) {
                    ctx.fillStyle = `rgba(100, 100, 100, ${Math.random() * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        Math.random() * 20 + 5,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                break;
                
            case 'Grass':
                // Grass texture
                for (let i = 0; i < 300; i++) {
                    ctx.strokeStyle = `rgb(${20 + Math.random() * 20}, ${100 + Math.random() * 40}, ${20 + Math.random() * 20})`;
                    ctx.beginPath();
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + (Math.random() * 10 - 5), y - Math.random() * 10);
                    ctx.stroke();
                }
                break;
                
            case 'Metal':
                // Metal texture
                ctx.fillStyle = '#888888';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add highlights
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add scratches
                for (let i = 0; i < 20; i++) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.lineTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.stroke();
                }
                break;
        }
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        
        // Add to textures array
        textures.push({
            texture: texture,
            name: texInfo.name
        });
        
        // Apply first texture to cube
        if (index === 0) {
            cubeMaterial.map = texture;
            cubeMaterial.needsUpdate = true;
        }
    });
    
    // Create a cube with the texture or fallback material
    const cubeGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    texturingGroup.add(cube);
    
    // Store cube reference for controls
    texturingGroup.cube = cube;

    // Create interactive controls - store elements so they can be shown/hidden
    texturingGroup.controlsElements = [];
    
    // Setup controls for when station is activated
    texturingGroup.setupControls = function() {
        // Remove any existing controls first
        this.removeControls();
        
        // Create controls container
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'station-controls texturing-controls';
        controlsContainer.style.position = 'absolute';
        controlsContainer.style.bottom = '20px';
        controlsContainer.style.left = '50%';
        controlsContainer.style.transform = 'translateX(-50%)';
        controlsContainer.style.padding = '10px';
        controlsContainer.style.backgroundColor = 'rgba(33, 150, 243, 0.7)';
        controlsContainer.style.borderRadius = '10px';
        controlsContainer.style.color = 'white';
        controlsContainer.style.fontFamily = 'Arial, sans-serif';
        controlsContainer.style.textAlign = 'center';
        controlsContainer.style.zIndex = '1000';
        document.body.appendChild(controlsContainer);
        this.controlsElements.push(controlsContainer);
        
        // Add title
        const title = document.createElement('h3');
        title.textContent = 'Texture Explorer!';
        title.style.margin = '0 0 10px 0';
        title.style.fontSize = '18px';
        controlsContainer.appendChild(title);

        // Texture selection
        const textureSection = document.createElement('div');
        textureSection.style.marginBottom = '15px';
        controlsContainer.appendChild(textureSection);
        
        const textureTitle = document.createElement('div');
        textureTitle.textContent = 'Choose a Texture:';
        textureTitle.style.marginBottom = '5px';
        textureSection.appendChild(textureTitle);
        
        // Create buttons for different textures
        const textureButtonsContainer = document.createElement('div');
        textureButtonsContainer.style.display = 'flex';
        textureButtonsContainer.style.justifyContent = 'center';
        textureButtonsContainer.style.flexWrap = 'wrap';
        textureButtonsContainer.style.gap = '5px';
        textureSection.appendChild(textureButtonsContainer);
        
        const applyTexture = (index) => {
            if (textures[index]) {
                cube.material.map = textures[index].texture;
                cube.material.needsUpdate = true;
                currentTextureIndex = index;
                
                // Update active button state
                document.querySelectorAll('.texture-btn').forEach((btn, i) => {
                    btn.style.border = i === index ? '2px solid white' : 'none';
                    btn.style.transform = i === index ? 'scale(1.1)' : 'scale(1)';
                });
            }
        };
        
        // Textures defined earlier in our load section
        const textureTypes = ['Bricks', 'Wood', 'Stone', 'Grass', 'Metal'];
        
        textureTypes.forEach((textureName, index) => {
            const textureBtn = document.createElement('button');
            textureBtn.className = 'texture-btn';
            textureBtn.textContent = textureName;
            textureBtn.style.padding = '6px 10px';
            textureBtn.style.backgroundColor = index === 0 ? '#1976D2' : '#2196F3';
            textureBtn.style.border = index === 0 ? '2px solid white' : 'none';
            
            textureBtn.addEventListener('click', () => {
                applyTexture(index);
            });
            
            textureButtonsContainer.appendChild(textureBtn);
        });
        
        // Texture repeat control
        const repeatSection = document.createElement('div');
        repeatSection.style.marginBottom = '15px';
        controlsContainer.appendChild(repeatSection);
        
        const repeatTitle = document.createElement('div');
        repeatTitle.textContent = 'Texture Repeat:';
        repeatTitle.style.marginBottom = '5px';
        repeatSection.appendChild(repeatTitle);
        
        const repeatSlider = document.createElement('input');
        repeatSlider.type = 'range';
        repeatSlider.min = '1';
        repeatSlider.max = '5';
        repeatSlider.step = '1';
        repeatSlider.value = '1';
        repeatSlider.style.width = '100%';
        repeatSlider.style.accentColor = '#2196F3';
        repeatSection.appendChild(repeatSlider);
        
        repeatSlider.addEventListener('input', () => {
            const repeatValue = parseInt(repeatSlider.value);
            textures.forEach(texItem => {
                texItem.texture.repeat.set(repeatValue, repeatValue);
                texItem.texture.needsUpdate = true;
            });
        });
        
        // Rotation control
        const rotationSection = document.createElement('div');
        controlsContainer.appendChild(rotationSection);
        
        const rotationTitle = document.createElement('div');
        rotationTitle.textContent = 'Spin Speed:';
        rotationTitle.style.marginBottom = '5px';
        rotationSection.appendChild(rotationTitle);
        
        const rotationSlider = document.createElement('input');
        rotationSlider.type = 'range';
        rotationSlider.min = '0';
        rotationSlider.max = '2';
        rotationSlider.step = '0.1';
        rotationSlider.value = '0.5';
        rotationSlider.style.width = '100%';
        rotationSlider.style.accentColor = '#2196F3';
        rotationSection.appendChild(rotationSlider);
        
        // Store the rotation speed
        this.rotationSpeed = parseFloat(rotationSlider.value);
        
        rotationSlider.addEventListener('input', () => {
            this.rotationSpeed = parseFloat(rotationSlider.value);
        });
    };
    
    // Method to remove controls
    texturingGroup.removeControls = function() {
        if (this.controlsElements) {
            this.controlsElements.forEach(element => {
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            this.controlsElements = [];
        }
    };
    
    // Default rotation speed
    texturingGroup.rotationSpeed = 0.5;
    
    // Add animation function to the group
    texturingGroup.update = function(time) {
        // Rotate the cube to show all sides
        cube.rotation.y = time * this.rotationSpeed;
        cube.rotation.x = Math.sin(time) * 0.2;
    };
    
    return texturingGroup;
}

/**
 * Creates a geometry demonstration
 */
function createGeometryDemo(position, color) {
    // Create a group for the geometry demo
    const geometryGroup = new THREE.Group();
    geometryGroup.position.copy(position);
    geometryGroup.position.y = 1.5;
    
    // Create different geometric shapes
    const shapes = [];
    
    // Tetrahedron
    const tetraGeometry = new THREE.TetrahedronGeometry(0.5);
    const tetraMaterial = new THREE.MeshStandardMaterial({
        color: 0xff5252,
        metalness: 0.2,
        roughness: 0.5
    });
    const tetrahedron = new THREE.Mesh(tetraGeometry, tetraMaterial);
    tetrahedron.position.set(-1, 0, 0);
    shapes.push(tetrahedron);
    geometryGroup.add(tetrahedron);
    
    // Octahedron
    const octaGeometry = new THREE.OctahedronGeometry(0.5);
    const octaMaterial = new THREE.MeshStandardMaterial({
        color: 0x4CAF50,
        metalness: 0.2,
        roughness: 0.5
    });
    const octahedron = new THREE.Mesh(octaGeometry, octaMaterial);
    octahedron.position.set(0, 0, 0);
    shapes.push(octahedron);
    geometryGroup.add(octahedron);
    
    // Dodecahedron
    const dodecaGeometry = new THREE.DodecahedronGeometry(0.5);
    const dodecaMaterial = new THREE.MeshStandardMaterial({
        color: 0x2196F3,
        metalness: 0.2,
        roughness: 0.5
    });
    const dodecahedron = new THREE.Mesh(dodecaGeometry, dodecaMaterial);
    dodecahedron.position.set(1, 0, 0);
    shapes.push(dodecahedron);
    geometryGroup.add(dodecahedron);
    
    // Add animation function to the group
    geometryGroup.update = function(time) {
        // Rotate each shape differently
        shapes.forEach((shape, index) => {
            shape.rotation.x = time * (0.5 + index * 0.2);
            shape.rotation.y = time * (0.3 + index * 0.1);
        });
    };
    
    return geometryGroup;
}

/**
 * Creates a shader demonstration
 */
function createShaderDemo(position, color) {
    // Create a group for the shader demo
    const shaderGroup = new THREE.Group();
    shaderGroup.position.copy(position);
    shaderGroup.position.y = 1.5;
    
    // Create a custom shader material
    const customShaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0.0 },
            color: { value: new THREE.Color(color) },
            waveSpeed: { value: 2.0 },
            waveCount: { value: 8.0 },
            colorMix: { value: 0.5 }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform vec3 color;
            uniform float waveSpeed;
            uniform float waveCount;
            uniform float colorMix;
            varying vec2 vUv;
            
            void main() {
                vec2 p = vUv * 2.0 - 1.0;
                float r = length(p);
                float a = atan(p.y, p.x);
                
                float f = sin(a * waveCount + time * waveSpeed) * 0.5 + 0.5;
                vec3 finalColor = mix(color, vec3(1.0), f * r * colorMix);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `
    });
    
    // Create a plane with the custom shader
    const planeGeometry = new THREE.PlaneGeometry(2, 2, 32, 32);
    const shaderPlane = new THREE.Mesh(planeGeometry, customShaderMaterial);
    shaderGroup.add(shaderPlane);
    
    // Store references for controls
    shaderGroup.material = customShaderMaterial;
    
    // Create interactive controls - store elements so they can be shown/hidden
    shaderGroup.controlsElements = [];
    
    // Setup controls for when station is activated
    shaderGroup.setupControls = function() {
        // Remove any existing controls first
        this.removeControls();
        
        // Create controls container
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'station-controls shader-controls';
        controlsContainer.style.position = 'absolute';
        controlsContainer.style.bottom = '20px';
        controlsContainer.style.left = '50%';
        controlsContainer.style.transform = 'translateX(-50%)';
        controlsContainer.style.padding = '10px';
        controlsContainer.style.backgroundColor = 'rgba(156, 39, 176, 0.7)';
        controlsContainer.style.borderRadius = '10px';
        controlsContainer.style.color = 'white';
        controlsContainer.style.fontFamily = 'Arial, sans-serif';
        controlsContainer.style.textAlign = 'center';
        controlsContainer.style.zIndex = '1000';
        controlsContainer.style.maxWidth = '300px';
        document.body.appendChild(controlsContainer);
        this.controlsElements.push(controlsContainer);
        
        // Add title
        const title = document.createElement('h3');
        title.textContent = 'Shader Magic!';
        title.style.margin = '0 0 10px 0';
        title.style.fontSize = '18px';
        controlsContainer.appendChild(title);
        
        // Color control section
        const colorSection = document.createElement('div');
        colorSection.style.marginBottom = '15px';
        controlsContainer.appendChild(colorSection);
        
        const colorTitle = document.createElement('div');
        colorTitle.textContent = 'Magic Color:';
        colorTitle.style.marginBottom = '5px';
        colorSection.appendChild(colorTitle);
        
        const colorButtons = document.createElement('div');
        colorButtons.style.display = 'flex';
        colorButtons.style.justifyContent = 'center';
        colorButtons.style.gap = '10px';
        colorSection.appendChild(colorButtons);
        
        // Define fun colors
        const shaderColors = [
            { name: 'Purple', value: '#9C27B0' },
            { name: 'Fire', value: '#FF5722' },
            { name: 'Ocean', value: '#03A9F4' },
            { name: 'Emerald', value: '#4CAF50' },
            { name: 'Gold', value: '#FFC107' }
        ];
        
        shaderColors.forEach(colorInfo => {
            const colorBtn = document.createElement('button');
            colorBtn.style.width = '20px';
            colorBtn.style.height = '20px';
            colorBtn.style.backgroundColor = colorInfo.value;
            colorBtn.style.border = 'none';
            colorBtn.style.borderRadius = '50%';
            colorBtn.style.cursor = 'pointer';
            colorBtn.title = colorInfo.name;
            
            colorBtn.addEventListener('click', () => {
                const newColor = new THREE.Color(colorInfo.value);
                customShaderMaterial.uniforms.color.value = newColor;
            });
            
            colorButtons.appendChild(colorBtn);
        });
        
        // Wave speed control
        const speedSection = document.createElement('div');
        speedSection.style.marginBottom = '15px';
        controlsContainer.appendChild(speedSection);
        
        const speedTitle = document.createElement('div');
        speedTitle.textContent = 'Wave Speed:';
        speedTitle.style.marginBottom = '5px';
        speedSection.appendChild(speedTitle);
        
        const speedSlider = document.createElement('input');
        speedSlider.type = 'range';
        speedSlider.min = '0.5';
        speedSlider.max = '5';
        speedSlider.step = '0.5';
        speedSlider.value = customShaderMaterial.uniforms.waveSpeed.value;
        speedSlider.style.width = '100%';
        speedSlider.style.accentColor = '#9C27B0';
        speedSection.appendChild(speedSlider);
        
        speedSlider.addEventListener('input', () => {
            customShaderMaterial.uniforms.waveSpeed.value = parseFloat(speedSlider.value);
        });
        
        // Wave count control
        const waveSection = document.createElement('div');
        waveSection.style.marginBottom = '15px';
        controlsContainer.appendChild(waveSection);
        
        const waveTitle = document.createElement('div');
        waveTitle.textContent = 'Wave Count:';
        waveTitle.style.marginBottom = '5px';
        waveSection.appendChild(waveTitle);
        
        const waveButtons = document.createElement('div');
        waveButtons.style.display = 'flex';
        waveButtons.style.justifyContent = 'center';
        waveButtons.style.gap = '5px';
        waveSection.appendChild(waveButtons);
        
        // Wave count buttons for kids (simple numbered buttons)
        [3, 6, 9, 12, 15].forEach(count => {
            const waveBtn = document.createElement('button');
            waveBtn.textContent = count;
            waveBtn.style.padding = '5px 10px';
            waveBtn.style.backgroundColor = count === 8 ? '#7B1FA2' : '#9C27B0';
            waveBtn.style.minWidth = '40px';
            
            waveBtn.addEventListener('click', () => {
                customShaderMaterial.uniforms.waveCount.value = count;
                
                // Update active button state
                document.querySelectorAll('.wave-count-btn').forEach(btn => {
                    btn.style.backgroundColor = '#9C27B0';
                });
                waveBtn.style.backgroundColor = '#7B1FA2';
            });
            
            waveBtn.className = 'wave-count-btn';
            waveButtons.appendChild(waveBtn);
        });
        
        // Color blend control
        const blendSection = document.createElement('div');
        controlsContainer.appendChild(blendSection);
        
        const blendTitle = document.createElement('div');
        blendTitle.textContent = 'Color Blend:';
        blendTitle.style.marginBottom = '5px';
        blendSection.appendChild(blendTitle);
        
        const blendSlider = document.createElement('input');
        blendSlider.type = 'range';
        blendSlider.min = '0';
        blendSlider.max = '1';
        blendSlider.step = '0.1';
        blendSlider.value = customShaderMaterial.uniforms.colorMix.value;
        blendSlider.style.width = '100%';
        blendSlider.style.accentColor = '#9C27B0';
        blendSection.appendChild(blendSlider);
        
        blendSlider.addEventListener('input', () => {
            customShaderMaterial.uniforms.colorMix.value = parseFloat(blendSlider.value);
        });
    };
    
    // Method to remove controls
    shaderGroup.removeControls = function() {
        if (this.controlsElements) {
            this.controlsElements.forEach(element => {
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            this.controlsElements = [];
        }
    };
    
    // Add animation function to the group
    shaderGroup.update = function(time) {
        // Update the shader time uniform
        customShaderMaterial.uniforms.time.value = time;
        
        // Rotate the plane slowly
        shaderPlane.rotation.z = time * 0.2;
    };
    
    return shaderGroup;
}

/**
 * Adds decorative elements to the world
 */
function addWorldDecorations() {
    // Add some trees
    addTrees();
    
    // Add a car model - Removed
    // addCarModel();
    
    // Add some floating particles
    addParticles();
}

/**
 * Adds trees to the world
 */
function addTrees() {
    // Create a simple tree
    function createTree(x, z) {
        const treeGroup = new THREE.Group();
        
        // Tree trunk - Larger
        const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 3.0, 8); // Increased size
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1.5; // Adjusted Y position for new height
        treeGroup.add(trunk);
        
        // Tree foliage - Larger
        const foliageGeometry = new THREE.ConeGeometry(2, 4, 8); // Increased size
        const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x2E8B57,
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 5.0; // Adjusted Y position (trunk height + foliage height/2)
        treeGroup.add(foliage);
        
        // Position the tree group base at terrain level (Y = -1 based on user's last change)
        treeGroup.position.set(x, -1, z);
        scene.add(treeGroup);
    }
    
    // Add trees at various positions
    const treePositions = [
        [-20, -10], [25, -20], [-15, 25], [30, 15],
        [-25, 5], [10, 30], [-30, -25], [20, -5]
    ];
    
    treePositions.forEach(pos => {
        createTree(pos[0], pos[1]);
    });
}

/**
 * Adds a car model to the world - Entire function removed
 */
/*
function addCarModel() {
    // ... (car creation code) ...
    return carGroup;
}
*/

/**
 * Adds floating particles to the world
 */
function addParticles() {
    // Create a particle system
    const particleCount = 500;
    const particles = new THREE.BufferGeometry();
    
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    // Create random positions and colors for particles
    for (let i = 0; i < particleCount; i++) {
        // Position
        positions[i * 3] = (Math.random() - 0.5) * 100; // x
        positions[i * 3 + 1] = Math.random() * 20 + 5;  // y
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100; // z
        
        // Color
        colors[i * 3] = Math.random(); // r
        colors[i * 3 + 1] = Math.random(); // g
        colors[i * 3 + 2] = Math.random(); // b
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    // Create particle material
    const particleMaterial = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.6
    });
    
    // Create the particle system
    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);
    
    // Add animation for particles
    particleSystem.update = function(time) {
        const positions = particles.attributes.position.array;
        
        for (let i = 0; i < particleCount; i++) {
            // Make particles float up and down
            positions[i * 3 + 1] += Math.sin(time + i) * 0.01;
            
            // Reset particles that go too high or too low
            if (positions[i * 3 + 1] > 30) positions[i * 3 + 1] = 5;
            if (positions[i * 3 + 1] < 5) positions[i * 3 + 1] = 30;
        }
        
        particles.attributes.position.needsUpdate = true;
    };
    
    return particleSystem;
}

/**
 * Updates all animated elements in the world
 */
function updateWorld(time) {
    const delta = clock.getDelta(); // Get delta time here for updates

    // Update learning station demos
    for (const stationKey in learningStations) {
        const station = learningStations[stationKey];
        if (station.demoObject && station.demoObject.update && station.demoObject.visible) {
            // Pass both elapsed time and delta time if needed
            station.demoObject.update(time, delta);
        }
    }
    
    // Update particle system
    if (scene.getObjectByName('particles') && scene.getObjectByName('particles').update) {
        scene.getObjectByName('particles').update(time);
    }
}

/**
 * Checks if the player is near a learning station and activates it if so
 */
function checkStationProximity() {
    try {
        // Get player position
        const playerPosition = camera.position;
        
        // Check distance to each station
        let nearestStation = null;
        let nearestDistance = 5; // Activation radius
        
        for (const stationKey in learningStations) {
            const station = learningStations[stationKey];
            const distance = playerPosition.distanceTo(station.position);
            
            if (distance < nearestDistance) {
                nearestDistance = distance;
                nearestStation = station;
            }
        }
        
        // Activate nearest station, deactivate others
        if (nearestStation !== currentStation) {
            // Deactivate current station if there is one
            if (currentStation) {
                currentStation.deactivate();
            }
            
            // Activate new station if there is one
            if (nearestStation) {
                nearestStation.activate();
            } else {
                // No station is nearby, reset UI
                const currentTopicElement = document.getElementById('current-topic');
                if (currentTopicElement) {
                    currentTopicElement.textContent = 'Explore';
                }
                
                const topicDescriptionElement = document.getElementById('topic-description');
                if (topicDescriptionElement) {
                    topicDescriptionElement.innerHTML = 
                        '<p>Move around the 3D world to discover learning stations about computer graphics concepts.</p>';
                }
                
                currentStation = null;
            }
        }
    } catch (error) {
        console.error('Error in checkStationProximity:', error);
    }
}

/**
 * Creates simple walls at the edge of the world
 */
function createWorldBorder() {
    const wallHeight = 20;
    const wallThickness = 1;
    const worldSize = 100; // Match terrain size
    const wallOffset = worldSize / 2 + wallThickness / 2; // Place walls just outside terrain

    const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x666666, side: THREE.DoubleSide });

    // Wall Geometry (long side)
    const wallGeometryX = new THREE.BoxGeometry(worldSize + wallThickness * 2, wallHeight, wallThickness);
    // Wall Geometry (short side)
    const wallGeometryZ = new THREE.BoxGeometry(wallThickness, wallHeight, worldSize + wallThickness * 2);

    // Wall +Z
    const wallPosZ = new THREE.Mesh(wallGeometryX, wallMaterial);
    wallPosZ.position.set(0, wallHeight / 2 - 1, wallOffset); // Adjust Y based on terrain Y=-1
    scene.add(wallPosZ);

    // Wall -Z
    const wallNegZ = new THREE.Mesh(wallGeometryX, wallMaterial);
    wallNegZ.position.set(0, wallHeight / 2 - 1, -wallOffset); // Adjust Y based on terrain Y=-1
    scene.add(wallNegZ);

    // Wall +X
    const wallPosX = new THREE.Mesh(wallGeometryZ, wallMaterial);
    wallPosX.position.set(wallOffset, wallHeight / 2 - 1, 0); // Adjust Y based on terrain Y=-1
    scene.add(wallPosX);

    // Wall -X
    const wallNegX = new THREE.Mesh(wallGeometryZ, wallMaterial);
    wallNegX.position.set(-wallOffset, wallHeight / 2 - 1, 0); // Adjust Y based on terrain Y=-1
    scene.add(wallNegX);

    console.log('World border walls created');
}

// Ensure functions are properly exposed to the global scope
console.log('World.js loaded, checking function availability');
if (typeof createWorld !== 'function') {
    console.error('createWorld function is not properly defined in the global scope');
    // Try to explicitly expose it
    window.createWorld = createWorld;
    window.createSkybox = createSkybox;
    window.createTerrain = createTerrain;
    window.checkStationProximity = checkStationProximity;
    window.updateWorld = updateWorld;
    console.log('Functions explicitly exposed to window object');
} else {
    console.log('createWorld function is properly defined in the global scope');
} 